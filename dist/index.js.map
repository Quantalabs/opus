{"version":3,"sources":["../webpack:/opus/external node-commonjs \"child_process\"","../webpack:/opus/external node-commonjs \"events\"","../webpack:/opus/external node-commonjs \"fs\"","../webpack:/opus/external node-commonjs \"path\"","../webpack:/opus/external node-commonjs \"process\"","../webpack:/opus/node_modules/commander/index.js","../webpack:/opus/node_modules/commander/lib/argument.js","../webpack:/opus/node_modules/commander/lib/command.js","../webpack:/opus/node_modules/commander/lib/error.js","../webpack:/opus/node_modules/commander/lib/help.js","../webpack:/opus/node_modules/commander/lib/option.js","../webpack:/opus/node_modules/commander/lib/suggestSimilar.js","../webpack:/opus/webpack/bootstrap","../webpack:/opus/webpack/runtime/compat get default export","../webpack:/opus/webpack/runtime/define property getters","../webpack:/opus/webpack/runtime/hasOwnProperty shorthand","../webpack:/opus/webpack/runtime/make namespace object","../webpack:/opus/opus/parse.ts","../webpack:/opus/node_modules/commander/esm.mjs","../webpack:/opus/opus/index.ts"],"names":["module","exports","require","Argument","__webpack_require__","Command","CommanderError","InvalidArgumentError","Help","Option","program","InvalidOptionArgumentError","constructor","name","description","this","variadic","parseArg","undefined","defaultValue","defaultValueDescription","argChoices","required","_name","slice","length","_concatValue","value","previous","Array","isArray","concat","default","argParser","fn","choices","values","arg","includes","join","argRequired","argOptional","humanReadableArgName","nameOutput","EventEmitter","childProcess","path","fs","process","splitOptionFlags","DualOptions","suggestSimilar","super","commands","options","parent","_allowUnknownOption","_allowExcessArguments","_args","args","rawArgs","processedArgs","_scriptPath","_optionValues","_optionValueSources","_storeOptionsAsProperties","_actionHandler","_executableHandler","_executableFile","_executableDir","_defaultCommandName","_exitCallback","_aliases","_combineFlagAndOptionalValue","_description","_summary","_argsDescription","_enablePositionalOptions","_passThroughOptions","_lifeCycleHooks","_showHelpAfterError","_showSuggestionAfterError","_outputConfiguration","writeOut","str","stdout","write","writeErr","stderr","getOutHelpWidth","isTTY","columns","getErrHelpWidth","outputError","_hidden","_hasHelpOption","_helpFlags","_helpDescription","_helpShortFlag","_helpLongFlag","_addImplicitHelpCommand","_helpCommandName","_helpCommandnameAndArgs","_helpCommandDescription","_helpConfiguration","copyInheritedSettings","sourceCommand","command","nameAndArgs","actionOptsOrExecDesc","execOpts","desc","opts","match","cmd","createCommand","isDefault","noHelp","hidden","executableFile","arguments","push","createHelp","Object","assign","configureHelp","configuration","configureOutput","showHelpAfterError","displayHelp","showSuggestionAfterError","displaySuggestion","addCommand","Error","createArgument","argument","addArgument","names","trim","split","forEach","detail","previousArgument","addHelpCommand","enableOrNameAndArgs","_hasImplicitHelpCommand","_findCommand","hook","event","listener","allowedValues","exitOverride","err","code","_exit","exitCode","message","exit","action","expectedArgsCount","actionArgs","apply","createOption","flags","addOption","option","oname","attributeName","negate","positiveLongFlag","long","replace","_findOption","setOptionValueWithSource","handleOptionValue","val","invalidValueMessage","valueSource","presetArg","oldValue","getOptionValue","error","isBoolean","optional","on","envVar","_optionEx","config","makeOptionMandatory","mandatory","RegExp","regex","def","m","exec","requiredOption","combineFlagAndOptionalValue","combine","allowUnknownOption","allowUnknown","allowExcessArguments","allowExcess","enablePositionalOptions","positional","passThroughOptions","passThrough","storeOptionsAsProperties","storeAsProperties","key","setOptionValue","source","getOptionValueSource","getOptionValueSourceWithGlobals","getCommandAndParents","_prepareUserArgs","argv","parseOptions","versions","electron","from","userArgs","defaultApp","nameFromFilename","parse","_parseCommand","async","_executeSubCommand","subcommand","launchWithNode","sourceExt","findFile","baseDir","baseName","localBin","resolve","existsSync","extname","foundExt","find","ext","_checkForMissingMandatoryOptions","_checkForConflictingOptions","executableDir","resolvedScriptPath","realpathSync","dirname","localFile","legacyName","basename","proc","platform","unshift","incrementNodeInspectorPort","execArgv","spawn","stdio","execPath","killed","signals","signal","kill","exitCallback","bind","executableDirMessage","executableMissing","wrappedError","nestedError","runningCommand","_dispatchSubcommand","commandName","operands","unknown","subCommand","help","hookResult","_chainOrCallSubCommandHook","_chainOrCall","_dispatchHelpCommand","subcommandName","_checkNumberOfArguments","i","missingArgument","_excessArguments","_processArguments","myParseArg","parsedValue","declaredArg","index","reduce","processed","v","promise","then","_chainOrCallHooks","result","hooks","reverse","filter","hookedCommand","callback","hookDetail","parsed","_parseOptionsEnv","_parseOptionsImplied","outputHelpIfRequested","checkForUnknownOptions","unknownOption","commandEvent","actionResult","emit","listenerCount","unknownCommand","is","anOption","missingMandatoryOptionValue","_checkForConflictingLocalOptions","definedNonDefaultOptions","optionKey","optionsWithConflicting","conflictsWith","conflictingAndDefined","defined","_conflictingOption","dest","maybeOption","activeVariadicOption","shift","optionMissingArgument","test","indexOf","len","_versionOptionName","_version","optsWithGlobals","combinedOptions","errorOptions","outputHelp","env","dualHelper","hasCustomOptionValue","implied","valueFromOption","keys","impliedKey","conflictingOption","findBestOptionFromValue","optionValue","negativeOption","target","positiveOption","getErrorMessage","bestOption","flag","suggestion","startsWith","candidateFlags","moreFlags","visibleOptions","map","receivedArgs","expected","s","forSubcommand","unknownName","candidateNames","visibleCommands","alias","version","versionOption","argsDescription","summary","aliases","usage","_usage","filename","helpInformation","contextOptions","helper","helpWidth","formatHelp","_getHelpContext","context","deprecatedCallback","Buffer","isBuffer","helpOption","helpFlags","shortFlag","longFlag","addHelpText","position","text","helpEvent","helpStr","debugOption","debugHost","debugPort","parseInt","startCommand","captureStackTrace","sortSubcommands","sortOptions","showGlobalOptions","helpName","helpArgs","helpCommand","sort","a","b","localeCompare","compareOptions","getSortKey","short","showShortHelpFlag","showLongHelpFlag","visibleGlobalOptions","globalOptions","parentCmd","visibleArguments","subcommandTerm","optionTerm","argumentTerm","longestSubcommandTermLength","max","Math","longestOptionTermLength","longestGlobalOptionTermLength","longestArgumentTermLength","commandUsage","cmdName","parentCmdNames","commandDescription","subcommandDescription","optionDescription","extraInfo","choice","JSON","stringify","showDefault","argumentDescription","extraDescripton","termWidth","padWidth","itemIndentWidth","itemSeparatorWidth","formatItem","term","fullText","padEnd","wrap","formatList","textArray","repeat","output","argumentList","optionList","globalOptionList","commandList","width","indent","minColumnWidth","indents","manualIndent","columnWidth","leadingStr","columnText","indentString","zeroWidthSpace","breaks","lines","line","trimEnd","optionFlags","preset","conflicts","implies","impliedOptionValues","newImplied","hideHelp","hide","camelcase","positiveOptions","Map","negativeOptions","dualOptions","Set","set","has","add","get","negativeValue","word","toUpperCase","flagParts","maxDistance","editDistance","abs","d","j","cost","min","candidates","searchingOptions","candidate","similar","bestDistance","minSimilarity","distance","similarity","__webpack_module_cache__","moduleId","cachedModule","threw","__webpack_modules__","n","getter","__esModule","definition","o","defineProperty","enumerable","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","processEscapeSequences","contentBlock","nonUnicodeEscapeSequences","escapeSequence","replacedContentBlock","String","fromCharCode","input","inputString","external_fs_default","readFileSync","tagRegex","tagMatch","tagName","optionsBlock","optionsDict","optionsLines","tagObject","content","opus_parse","commander","console","log"],"mappings":"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","file":"index.js","sourcesContent":["module.exports = require(\"child_process\");","module.exports = require(\"events\");","module.exports = require(\"fs\");","module.exports = require(\"path\");","module.exports = require(\"process\");","const { Argument } = require('./lib/argument.js');\nconst { Command } = require('./lib/command.js');\nconst { CommanderError, InvalidArgumentError } = require('./lib/error.js');\nconst { Help } = require('./lib/help.js');\nconst { Option } = require('./lib/option.js');\n\n// @ts-check\n\n/**\n * Expose the root command.\n */\n\nexports = module.exports = new Command();\nexports.program = exports; // More explicit access to global command.\n// Implicit export of createArgument, createCommand, and createOption.\n\n/**\n * Expose classes\n */\n\nexports.Argument = Argument;\nexports.Command = Command;\nexports.CommanderError = CommanderError;\nexports.Help = Help;\nexports.InvalidArgumentError = InvalidArgumentError;\nexports.InvalidOptionArgumentError = InvalidArgumentError; // Deprecated\nexports.Option = Option;\n","const { InvalidArgumentError } = require('./error.js');\n\n// @ts-check\n\nclass Argument {\n  /**\n   * Initialize a new command argument with the given name and description.\n   * The default is that the argument is required, and you can explicitly\n   * indicate this with <> around the name. Put [] around the name for an optional argument.\n   *\n   * @param {string} name\n   * @param {string} [description]\n   */\n\n  constructor(name, description) {\n    this.description = description || '';\n    this.variadic = false;\n    this.parseArg = undefined;\n    this.defaultValue = undefined;\n    this.defaultValueDescription = undefined;\n    this.argChoices = undefined;\n\n    switch (name[0]) {\n      case '<': // e.g. <required>\n        this.required = true;\n        this._name = name.slice(1, -1);\n        break;\n      case '[': // e.g. [optional]\n        this.required = false;\n        this._name = name.slice(1, -1);\n        break;\n      default:\n        this.required = true;\n        this._name = name;\n        break;\n    }\n\n    if (this._name.length > 3 && this._name.slice(-3) === '...') {\n      this.variadic = true;\n      this._name = this._name.slice(0, -3);\n    }\n  }\n\n  /**\n   * Return argument name.\n   *\n   * @return {string}\n   */\n\n  name() {\n    return this._name;\n  }\n\n  /**\n   * @api private\n   */\n\n  _concatValue(value, previous) {\n    if (previous === this.defaultValue || !Array.isArray(previous)) {\n      return [value];\n    }\n\n    return previous.concat(value);\n  }\n\n  /**\n   * Set the default value, and optionally supply the description to be displayed in the help.\n   *\n   * @param {any} value\n   * @param {string} [description]\n   * @return {Argument}\n   */\n\n  default(value, description) {\n    this.defaultValue = value;\n    this.defaultValueDescription = description;\n    return this;\n  }\n\n  /**\n   * Set the custom handler for processing CLI command arguments into argument values.\n   *\n   * @param {Function} [fn]\n   * @return {Argument}\n   */\n\n  argParser(fn) {\n    this.parseArg = fn;\n    return this;\n  }\n\n  /**\n   * Only allow argument value to be one of choices.\n   *\n   * @param {string[]} values\n   * @return {Argument}\n   */\n\n  choices(values) {\n    this.argChoices = values.slice();\n    this.parseArg = (arg, previous) => {\n      if (!this.argChoices.includes(arg)) {\n        throw new InvalidArgumentError(`Allowed choices are ${this.argChoices.join(', ')}.`);\n      }\n      if (this.variadic) {\n        return this._concatValue(arg, previous);\n      }\n      return arg;\n    };\n    return this;\n  }\n\n  /**\n   * Make argument required.\n   */\n  argRequired() {\n    this.required = true;\n    return this;\n  }\n\n  /**\n   * Make argument optional.\n   */\n  argOptional() {\n    this.required = false;\n    return this;\n  }\n}\n\n/**\n * Takes an argument and returns its human readable equivalent for help usage.\n *\n * @param {Argument} arg\n * @return {string}\n * @api private\n */\n\nfunction humanReadableArgName(arg) {\n  const nameOutput = arg.name() + (arg.variadic === true ? '...' : '');\n\n  return arg.required\n    ? '<' + nameOutput + '>'\n    : '[' + nameOutput + ']';\n}\n\nexports.Argument = Argument;\nexports.humanReadableArgName = humanReadableArgName;\n","const EventEmitter = require('events').EventEmitter;\nconst childProcess = require('child_process');\nconst path = require('path');\nconst fs = require('fs');\nconst process = require('process');\n\nconst { Argument, humanReadableArgName } = require('./argument.js');\nconst { CommanderError } = require('./error.js');\nconst { Help } = require('./help.js');\nconst { Option, splitOptionFlags, DualOptions } = require('./option.js');\nconst { suggestSimilar } = require('./suggestSimilar');\n\n// @ts-check\n\nclass Command extends EventEmitter {\n  /**\n   * Initialize a new `Command`.\n   *\n   * @param {string} [name]\n   */\n\n  constructor(name) {\n    super();\n    /** @type {Command[]} */\n    this.commands = [];\n    /** @type {Option[]} */\n    this.options = [];\n    this.parent = null;\n    this._allowUnknownOption = false;\n    this._allowExcessArguments = true;\n    /** @type {Argument[]} */\n    this._args = [];\n    /** @type {string[]} */\n    this.args = []; // cli args with options removed\n    this.rawArgs = [];\n    this.processedArgs = []; // like .args but after custom processing and collecting variadic\n    this._scriptPath = null;\n    this._name = name || '';\n    this._optionValues = {};\n    this._optionValueSources = {}; // default, env, cli etc\n    this._storeOptionsAsProperties = false;\n    this._actionHandler = null;\n    this._executableHandler = false;\n    this._executableFile = null; // custom name for executable\n    this._executableDir = null; // custom search directory for subcommands\n    this._defaultCommandName = null;\n    this._exitCallback = null;\n    this._aliases = [];\n    this._combineFlagAndOptionalValue = true;\n    this._description = '';\n    this._summary = '';\n    this._argsDescription = undefined; // legacy\n    this._enablePositionalOptions = false;\n    this._passThroughOptions = false;\n    this._lifeCycleHooks = {}; // a hash of arrays\n    /** @type {boolean | string} */\n    this._showHelpAfterError = false;\n    this._showSuggestionAfterError = true;\n\n    // see .configureOutput() for docs\n    this._outputConfiguration = {\n      writeOut: (str) => process.stdout.write(str),\n      writeErr: (str) => process.stderr.write(str),\n      getOutHelpWidth: () => process.stdout.isTTY ? process.stdout.columns : undefined,\n      getErrHelpWidth: () => process.stderr.isTTY ? process.stderr.columns : undefined,\n      outputError: (str, write) => write(str)\n    };\n\n    this._hidden = false;\n    this._hasHelpOption = true;\n    this._helpFlags = '-h, --help';\n    this._helpDescription = 'display help for command';\n    this._helpShortFlag = '-h';\n    this._helpLongFlag = '--help';\n    this._addImplicitHelpCommand = undefined; // Deliberately undefined, not decided whether true or false\n    this._helpCommandName = 'help';\n    this._helpCommandnameAndArgs = 'help [command]';\n    this._helpCommandDescription = 'display help for command';\n    this._helpConfiguration = {};\n  }\n\n  /**\n   * Copy settings that are useful to have in common across root command and subcommands.\n   *\n   * (Used internally when adding a command using `.command()` so subcommands inherit parent settings.)\n   *\n   * @param {Command} sourceCommand\n   * @return {Command} `this` command for chaining\n   */\n  copyInheritedSettings(sourceCommand) {\n    this._outputConfiguration = sourceCommand._outputConfiguration;\n    this._hasHelpOption = sourceCommand._hasHelpOption;\n    this._helpFlags = sourceCommand._helpFlags;\n    this._helpDescription = sourceCommand._helpDescription;\n    this._helpShortFlag = sourceCommand._helpShortFlag;\n    this._helpLongFlag = sourceCommand._helpLongFlag;\n    this._helpCommandName = sourceCommand._helpCommandName;\n    this._helpCommandnameAndArgs = sourceCommand._helpCommandnameAndArgs;\n    this._helpCommandDescription = sourceCommand._helpCommandDescription;\n    this._helpConfiguration = sourceCommand._helpConfiguration;\n    this._exitCallback = sourceCommand._exitCallback;\n    this._storeOptionsAsProperties = sourceCommand._storeOptionsAsProperties;\n    this._combineFlagAndOptionalValue = sourceCommand._combineFlagAndOptionalValue;\n    this._allowExcessArguments = sourceCommand._allowExcessArguments;\n    this._enablePositionalOptions = sourceCommand._enablePositionalOptions;\n    this._showHelpAfterError = sourceCommand._showHelpAfterError;\n    this._showSuggestionAfterError = sourceCommand._showSuggestionAfterError;\n\n    return this;\n  }\n\n  /**\n   * Define a command.\n   *\n   * There are two styles of command: pay attention to where to put the description.\n   *\n   * @example\n   * // Command implemented using action handler (description is supplied separately to `.command`)\n   * program\n   *   .command('clone <source> [destination]')\n   *   .description('clone a repository into a newly created directory')\n   *   .action((source, destination) => {\n   *     console.log('clone command called');\n   *   });\n   *\n   * // Command implemented using separate executable file (description is second parameter to `.command`)\n   * program\n   *   .command('start <service>', 'start named service')\n   *   .command('stop [service]', 'stop named service, or all if no name supplied');\n   *\n   * @param {string} nameAndArgs - command name and arguments, args are `<required>` or `[optional]` and last may also be `variadic...`\n   * @param {Object|string} [actionOptsOrExecDesc] - configuration options (for action), or description (for executable)\n   * @param {Object} [execOpts] - configuration options (for executable)\n   * @return {Command} returns new command for action handler, or `this` for executable command\n   */\n\n  command(nameAndArgs, actionOptsOrExecDesc, execOpts) {\n    let desc = actionOptsOrExecDesc;\n    let opts = execOpts;\n    if (typeof desc === 'object' && desc !== null) {\n      opts = desc;\n      desc = null;\n    }\n    opts = opts || {};\n    const [, name, args] = nameAndArgs.match(/([^ ]+) *(.*)/);\n\n    const cmd = this.createCommand(name);\n    if (desc) {\n      cmd.description(desc);\n      cmd._executableHandler = true;\n    }\n    if (opts.isDefault) this._defaultCommandName = cmd._name;\n    cmd._hidden = !!(opts.noHelp || opts.hidden); // noHelp is deprecated old name for hidden\n    cmd._executableFile = opts.executableFile || null; // Custom name for executable file, set missing to null to match constructor\n    if (args) cmd.arguments(args);\n    this.commands.push(cmd);\n    cmd.parent = this;\n    cmd.copyInheritedSettings(this);\n\n    if (desc) return this;\n    return cmd;\n  }\n\n  /**\n   * Factory routine to create a new unattached command.\n   *\n   * See .command() for creating an attached subcommand, which uses this routine to\n   * create the command. You can override createCommand to customise subcommands.\n   *\n   * @param {string} [name]\n   * @return {Command} new command\n   */\n\n  createCommand(name) {\n    return new Command(name);\n  }\n\n  /**\n   * You can customise the help with a subclass of Help by overriding createHelp,\n   * or by overriding Help properties using configureHelp().\n   *\n   * @return {Help}\n   */\n\n  createHelp() {\n    return Object.assign(new Help(), this.configureHelp());\n  }\n\n  /**\n   * You can customise the help by overriding Help properties using configureHelp(),\n   * or with a subclass of Help by overriding createHelp().\n   *\n   * @param {Object} [configuration] - configuration options\n   * @return {Command|Object} `this` command for chaining, or stored configuration\n   */\n\n  configureHelp(configuration) {\n    if (configuration === undefined) return this._helpConfiguration;\n\n    this._helpConfiguration = configuration;\n    return this;\n  }\n\n  /**\n   * The default output goes to stdout and stderr. You can customise this for special\n   * applications. You can also customise the display of errors by overriding outputError.\n   *\n   * The configuration properties are all functions:\n   *\n   *     // functions to change where being written, stdout and stderr\n   *     writeOut(str)\n   *     writeErr(str)\n   *     // matching functions to specify width for wrapping help\n   *     getOutHelpWidth()\n   *     getErrHelpWidth()\n   *     // functions based on what is being written out\n   *     outputError(str, write) // used for displaying errors, and not used for displaying help\n   *\n   * @param {Object} [configuration] - configuration options\n   * @return {Command|Object} `this` command for chaining, or stored configuration\n   */\n\n  configureOutput(configuration) {\n    if (configuration === undefined) return this._outputConfiguration;\n\n    Object.assign(this._outputConfiguration, configuration);\n    return this;\n  }\n\n  /**\n   * Display the help or a custom message after an error occurs.\n   *\n   * @param {boolean|string} [displayHelp]\n   * @return {Command} `this` command for chaining\n   */\n  showHelpAfterError(displayHelp = true) {\n    if (typeof displayHelp !== 'string') displayHelp = !!displayHelp;\n    this._showHelpAfterError = displayHelp;\n    return this;\n  }\n\n  /**\n   * Display suggestion of similar commands for unknown commands, or options for unknown options.\n   *\n   * @param {boolean} [displaySuggestion]\n   * @return {Command} `this` command for chaining\n   */\n  showSuggestionAfterError(displaySuggestion = true) {\n    this._showSuggestionAfterError = !!displaySuggestion;\n    return this;\n  }\n\n  /**\n   * Add a prepared subcommand.\n   *\n   * See .command() for creating an attached subcommand which inherits settings from its parent.\n   *\n   * @param {Command} cmd - new subcommand\n   * @param {Object} [opts] - configuration options\n   * @return {Command} `this` command for chaining\n   */\n\n  addCommand(cmd, opts) {\n    if (!cmd._name) {\n      throw new Error(`Command passed to .addCommand() must have a name\n- specify the name in Command constructor or using .name()`);\n    }\n\n    opts = opts || {};\n    if (opts.isDefault) this._defaultCommandName = cmd._name;\n    if (opts.noHelp || opts.hidden) cmd._hidden = true; // modifying passed command due to existing implementation\n\n    this.commands.push(cmd);\n    cmd.parent = this;\n    return this;\n  }\n\n  /**\n   * Factory routine to create a new unattached argument.\n   *\n   * See .argument() for creating an attached argument, which uses this routine to\n   * create the argument. You can override createArgument to return a custom argument.\n   *\n   * @param {string} name\n   * @param {string} [description]\n   * @return {Argument} new argument\n   */\n\n  createArgument(name, description) {\n    return new Argument(name, description);\n  }\n\n  /**\n   * Define argument syntax for command.\n   *\n   * The default is that the argument is required, and you can explicitly\n   * indicate this with <> around the name. Put [] around the name for an optional argument.\n   *\n   * @example\n   * program.argument('<input-file>');\n   * program.argument('[output-file]');\n   *\n   * @param {string} name\n   * @param {string} [description]\n   * @param {Function|*} [fn] - custom argument processing function\n   * @param {*} [defaultValue]\n   * @return {Command} `this` command for chaining\n   */\n  argument(name, description, fn, defaultValue) {\n    const argument = this.createArgument(name, description);\n    if (typeof fn === 'function') {\n      argument.default(defaultValue).argParser(fn);\n    } else {\n      argument.default(fn);\n    }\n    this.addArgument(argument);\n    return this;\n  }\n\n  /**\n   * Define argument syntax for command, adding multiple at once (without descriptions).\n   *\n   * See also .argument().\n   *\n   * @example\n   * program.arguments('<cmd> [env]');\n   *\n   * @param {string} names\n   * @return {Command} `this` command for chaining\n   */\n\n  arguments(names) {\n    names.trim().split(/ +/).forEach((detail) => {\n      this.argument(detail);\n    });\n    return this;\n  }\n\n  /**\n   * Define argument syntax for command, adding a prepared argument.\n   *\n   * @param {Argument} argument\n   * @return {Command} `this` command for chaining\n   */\n  addArgument(argument) {\n    const previousArgument = this._args.slice(-1)[0];\n    if (previousArgument && previousArgument.variadic) {\n      throw new Error(`only the last argument can be variadic '${previousArgument.name()}'`);\n    }\n    if (argument.required && argument.defaultValue !== undefined && argument.parseArg === undefined) {\n      throw new Error(`a default value for a required argument is never used: '${argument.name()}'`);\n    }\n    this._args.push(argument);\n    return this;\n  }\n\n  /**\n   * Override default decision whether to add implicit help command.\n   *\n   *    addHelpCommand() // force on\n   *    addHelpCommand(false); // force off\n   *    addHelpCommand('help [cmd]', 'display help for [cmd]'); // force on with custom details\n   *\n   * @return {Command} `this` command for chaining\n   */\n\n  addHelpCommand(enableOrNameAndArgs, description) {\n    if (enableOrNameAndArgs === false) {\n      this._addImplicitHelpCommand = false;\n    } else {\n      this._addImplicitHelpCommand = true;\n      if (typeof enableOrNameAndArgs === 'string') {\n        this._helpCommandName = enableOrNameAndArgs.split(' ')[0];\n        this._helpCommandnameAndArgs = enableOrNameAndArgs;\n      }\n      this._helpCommandDescription = description || this._helpCommandDescription;\n    }\n    return this;\n  }\n\n  /**\n   * @return {boolean}\n   * @api private\n   */\n\n  _hasImplicitHelpCommand() {\n    if (this._addImplicitHelpCommand === undefined) {\n      return this.commands.length && !this._actionHandler && !this._findCommand('help');\n    }\n    return this._addImplicitHelpCommand;\n  }\n\n  /**\n   * Add hook for life cycle event.\n   *\n   * @param {string} event\n   * @param {Function} listener\n   * @return {Command} `this` command for chaining\n   */\n\n  hook(event, listener) {\n    const allowedValues = ['preSubcommand', 'preAction', 'postAction'];\n    if (!allowedValues.includes(event)) {\n      throw new Error(`Unexpected value for event passed to hook : '${event}'.\nExpecting one of '${allowedValues.join(\"', '\")}'`);\n    }\n    if (this._lifeCycleHooks[event]) {\n      this._lifeCycleHooks[event].push(listener);\n    } else {\n      this._lifeCycleHooks[event] = [listener];\n    }\n    return this;\n  }\n\n  /**\n   * Register callback to use as replacement for calling process.exit.\n   *\n   * @param {Function} [fn] optional callback which will be passed a CommanderError, defaults to throwing\n   * @return {Command} `this` command for chaining\n   */\n\n  exitOverride(fn) {\n    if (fn) {\n      this._exitCallback = fn;\n    } else {\n      this._exitCallback = (err) => {\n        if (err.code !== 'commander.executeSubCommandAsync') {\n          throw err;\n        } else {\n          // Async callback from spawn events, not useful to throw.\n        }\n      };\n    }\n    return this;\n  }\n\n  /**\n   * Call process.exit, and _exitCallback if defined.\n   *\n   * @param {number} exitCode exit code for using with process.exit\n   * @param {string} code an id string representing the error\n   * @param {string} message human-readable description of the error\n   * @return never\n   * @api private\n   */\n\n  _exit(exitCode, code, message) {\n    if (this._exitCallback) {\n      this._exitCallback(new CommanderError(exitCode, code, message));\n      // Expecting this line is not reached.\n    }\n    process.exit(exitCode);\n  }\n\n  /**\n   * Register callback `fn` for the command.\n   *\n   * @example\n   * program\n   *   .command('serve')\n   *   .description('start service')\n   *   .action(function() {\n   *      // do work here\n   *   });\n   *\n   * @param {Function} fn\n   * @return {Command} `this` command for chaining\n   */\n\n  action(fn) {\n    const listener = (args) => {\n      // The .action callback takes an extra parameter which is the command or options.\n      const expectedArgsCount = this._args.length;\n      const actionArgs = args.slice(0, expectedArgsCount);\n      if (this._storeOptionsAsProperties) {\n        actionArgs[expectedArgsCount] = this; // backwards compatible \"options\"\n      } else {\n        actionArgs[expectedArgsCount] = this.opts();\n      }\n      actionArgs.push(this);\n\n      return fn.apply(this, actionArgs);\n    };\n    this._actionHandler = listener;\n    return this;\n  }\n\n  /**\n   * Factory routine to create a new unattached option.\n   *\n   * See .option() for creating an attached option, which uses this routine to\n   * create the option. You can override createOption to return a custom option.\n   *\n   * @param {string} flags\n   * @param {string} [description]\n   * @return {Option} new option\n   */\n\n  createOption(flags, description) {\n    return new Option(flags, description);\n  }\n\n  /**\n   * Add an option.\n   *\n   * @param {Option} option\n   * @return {Command} `this` command for chaining\n   */\n  addOption(option) {\n    const oname = option.name();\n    const name = option.attributeName();\n\n    // store default value\n    if (option.negate) {\n      // --no-foo is special and defaults foo to true, unless a --foo option is already defined\n      const positiveLongFlag = option.long.replace(/^--no-/, '--');\n      if (!this._findOption(positiveLongFlag)) {\n        this.setOptionValueWithSource(name, option.defaultValue === undefined ? true : option.defaultValue, 'default');\n      }\n    } else if (option.defaultValue !== undefined) {\n      this.setOptionValueWithSource(name, option.defaultValue, 'default');\n    }\n\n    // register the option\n    this.options.push(option);\n\n    // handler for cli and env supplied values\n    const handleOptionValue = (val, invalidValueMessage, valueSource) => {\n      // val is null for optional option used without an optional-argument.\n      // val is undefined for boolean and negated option.\n      if (val == null && option.presetArg !== undefined) {\n        val = option.presetArg;\n      }\n\n      // custom processing\n      const oldValue = this.getOptionValue(name);\n      if (val !== null && option.parseArg) {\n        try {\n          val = option.parseArg(val, oldValue);\n        } catch (err) {\n          if (err.code === 'commander.invalidArgument') {\n            const message = `${invalidValueMessage} ${err.message}`;\n            this.error(message, { exitCode: err.exitCode, code: err.code });\n          }\n          throw err;\n        }\n      } else if (val !== null && option.variadic) {\n        val = option._concatValue(val, oldValue);\n      }\n\n      // Fill-in appropriate missing values. Long winded but easy to follow.\n      if (val == null) {\n        if (option.negate) {\n          val = false;\n        } else if (option.isBoolean() || option.optional) {\n          val = true;\n        } else {\n          val = ''; // not normal, parseArg might have failed or be a mock function for testing\n        }\n      }\n      this.setOptionValueWithSource(name, val, valueSource);\n    };\n\n    this.on('option:' + oname, (val) => {\n      const invalidValueMessage = `error: option '${option.flags}' argument '${val}' is invalid.`;\n      handleOptionValue(val, invalidValueMessage, 'cli');\n    });\n\n    if (option.envVar) {\n      this.on('optionEnv:' + oname, (val) => {\n        const invalidValueMessage = `error: option '${option.flags}' value '${val}' from env '${option.envVar}' is invalid.`;\n        handleOptionValue(val, invalidValueMessage, 'env');\n      });\n    }\n\n    return this;\n  }\n\n  /**\n   * Internal implementation shared by .option() and .requiredOption()\n   *\n   * @api private\n   */\n  _optionEx(config, flags, description, fn, defaultValue) {\n    if (typeof flags === 'object' && flags instanceof Option) {\n      throw new Error('To add an Option object use addOption() instead of option() or requiredOption()');\n    }\n    const option = this.createOption(flags, description);\n    option.makeOptionMandatory(!!config.mandatory);\n    if (typeof fn === 'function') {\n      option.default(defaultValue).argParser(fn);\n    } else if (fn instanceof RegExp) {\n      // deprecated\n      const regex = fn;\n      fn = (val, def) => {\n        const m = regex.exec(val);\n        return m ? m[0] : def;\n      };\n      option.default(defaultValue).argParser(fn);\n    } else {\n      option.default(fn);\n    }\n\n    return this.addOption(option);\n  }\n\n  /**\n   * Define option with `flags`, `description` and optional\n   * coercion `fn`.\n   *\n   * The `flags` string contains the short and/or long flags,\n   * separated by comma, a pipe or space. The following are all valid\n   * all will output this way when `--help` is used.\n   *\n   *     \"-p, --pepper\"\n   *     \"-p|--pepper\"\n   *     \"-p --pepper\"\n   *\n   * @example\n   * // simple boolean defaulting to undefined\n   * program.option('-p, --pepper', 'add pepper');\n   *\n   * program.pepper\n   * // => undefined\n   *\n   * --pepper\n   * program.pepper\n   * // => true\n   *\n   * // simple boolean defaulting to true (unless non-negated option is also defined)\n   * program.option('-C, --no-cheese', 'remove cheese');\n   *\n   * program.cheese\n   * // => true\n   *\n   * --no-cheese\n   * program.cheese\n   * // => false\n   *\n   * // required argument\n   * program.option('-C, --chdir <path>', 'change the working directory');\n   *\n   * --chdir /tmp\n   * program.chdir\n   * // => \"/tmp\"\n   *\n   * // optional argument\n   * program.option('-c, --cheese [type]', 'add cheese [marble]');\n   *\n   * @param {string} flags\n   * @param {string} [description]\n   * @param {Function|*} [fn] - custom option processing function or default value\n   * @param {*} [defaultValue]\n   * @return {Command} `this` command for chaining\n   */\n\n  option(flags, description, fn, defaultValue) {\n    return this._optionEx({}, flags, description, fn, defaultValue);\n  }\n\n  /**\n  * Add a required option which must have a value after parsing. This usually means\n  * the option must be specified on the command line. (Otherwise the same as .option().)\n  *\n  * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space.\n  *\n  * @param {string} flags\n  * @param {string} [description]\n  * @param {Function|*} [fn] - custom option processing function or default value\n  * @param {*} [defaultValue]\n  * @return {Command} `this` command for chaining\n  */\n\n  requiredOption(flags, description, fn, defaultValue) {\n    return this._optionEx({ mandatory: true }, flags, description, fn, defaultValue);\n  }\n\n  /**\n   * Alter parsing of short flags with optional values.\n   *\n   * @example\n   * // for `.option('-f,--flag [value]'):\n   * program.combineFlagAndOptionalValue(true);  // `-f80` is treated like `--flag=80`, this is the default behaviour\n   * program.combineFlagAndOptionalValue(false) // `-fb` is treated like `-f -b`\n   *\n   * @param {Boolean} [combine=true] - if `true` or omitted, an optional value can be specified directly after the flag.\n   */\n  combineFlagAndOptionalValue(combine = true) {\n    this._combineFlagAndOptionalValue = !!combine;\n    return this;\n  }\n\n  /**\n   * Allow unknown options on the command line.\n   *\n   * @param {Boolean} [allowUnknown=true] - if `true` or omitted, no error will be thrown\n   * for unknown options.\n   */\n  allowUnknownOption(allowUnknown = true) {\n    this._allowUnknownOption = !!allowUnknown;\n    return this;\n  }\n\n  /**\n   * Allow excess command-arguments on the command line. Pass false to make excess arguments an error.\n   *\n   * @param {Boolean} [allowExcess=true] - if `true` or omitted, no error will be thrown\n   * for excess arguments.\n   */\n  allowExcessArguments(allowExcess = true) {\n    this._allowExcessArguments = !!allowExcess;\n    return this;\n  }\n\n  /**\n   * Enable positional options. Positional means global options are specified before subcommands which lets\n   * subcommands reuse the same option names, and also enables subcommands to turn on passThroughOptions.\n   * The default behaviour is non-positional and global options may appear anywhere on the command line.\n   *\n   * @param {Boolean} [positional=true]\n   */\n  enablePositionalOptions(positional = true) {\n    this._enablePositionalOptions = !!positional;\n    return this;\n  }\n\n  /**\n   * Pass through options that come after command-arguments rather than treat them as command-options,\n   * so actual command-options come before command-arguments. Turning this on for a subcommand requires\n   * positional options to have been enabled on the program (parent commands).\n   * The default behaviour is non-positional and options may appear before or after command-arguments.\n   *\n   * @param {Boolean} [passThrough=true]\n   * for unknown options.\n   */\n  passThroughOptions(passThrough = true) {\n    this._passThroughOptions = !!passThrough;\n    if (!!this.parent && passThrough && !this.parent._enablePositionalOptions) {\n      throw new Error('passThroughOptions can not be used without turning on enablePositionalOptions for parent command(s)');\n    }\n    return this;\n  }\n\n  /**\n    * Whether to store option values as properties on command object,\n    * or store separately (specify false). In both cases the option values can be accessed using .opts().\n    *\n    * @param {boolean} [storeAsProperties=true]\n    * @return {Command} `this` command for chaining\n    */\n\n  storeOptionsAsProperties(storeAsProperties = true) {\n    this._storeOptionsAsProperties = !!storeAsProperties;\n    if (this.options.length) {\n      throw new Error('call .storeOptionsAsProperties() before adding options');\n    }\n    return this;\n  }\n\n  /**\n   * Retrieve option value.\n   *\n   * @param {string} key\n   * @return {Object} value\n   */\n\n  getOptionValue(key) {\n    if (this._storeOptionsAsProperties) {\n      return this[key];\n    }\n    return this._optionValues[key];\n  }\n\n  /**\n   * Store option value.\n   *\n   * @param {string} key\n   * @param {Object} value\n   * @return {Command} `this` command for chaining\n   */\n\n  setOptionValue(key, value) {\n    return this.setOptionValueWithSource(key, value, undefined);\n  }\n\n  /**\n    * Store option value and where the value came from.\n    *\n    * @param {string} key\n    * @param {Object} value\n    * @param {string} source - expected values are default/config/env/cli/implied\n    * @return {Command} `this` command for chaining\n    */\n\n  setOptionValueWithSource(key, value, source) {\n    if (this._storeOptionsAsProperties) {\n      this[key] = value;\n    } else {\n      this._optionValues[key] = value;\n    }\n    this._optionValueSources[key] = source;\n    return this;\n  }\n\n  /**\n    * Get source of option value.\n    * Expected values are default | config | env | cli | implied\n    *\n    * @param {string} key\n    * @return {string}\n    */\n\n  getOptionValueSource(key) {\n    return this._optionValueSources[key];\n  }\n\n  /**\n    * Get source of option value. See also .optsWithGlobals().\n    * Expected values are default | config | env | cli | implied\n    *\n    * @param {string} key\n    * @return {string}\n    */\n\n  getOptionValueSourceWithGlobals(key) {\n    // global overwrites local, like optsWithGlobals\n    let source;\n    getCommandAndParents(this).forEach((cmd) => {\n      if (cmd.getOptionValueSource(key) !== undefined) {\n        source = cmd.getOptionValueSource(key);\n      }\n    });\n    return source;\n  }\n\n  /**\n   * Get user arguments from implied or explicit arguments.\n   * Side-effects: set _scriptPath if args included script. Used for default program name, and subcommand searches.\n   *\n   * @api private\n   */\n\n  _prepareUserArgs(argv, parseOptions) {\n    if (argv !== undefined && !Array.isArray(argv)) {\n      throw new Error('first parameter to parse must be array or undefined');\n    }\n    parseOptions = parseOptions || {};\n\n    // Default to using process.argv\n    if (argv === undefined) {\n      argv = process.argv;\n      // @ts-ignore: unknown property\n      if (process.versions && process.versions.electron) {\n        parseOptions.from = 'electron';\n      }\n    }\n    this.rawArgs = argv.slice();\n\n    // make it a little easier for callers by supporting various argv conventions\n    let userArgs;\n    switch (parseOptions.from) {\n      case undefined:\n      case 'node':\n        this._scriptPath = argv[1];\n        userArgs = argv.slice(2);\n        break;\n      case 'electron':\n        // @ts-ignore: unknown property\n        if (process.defaultApp) {\n          this._scriptPath = argv[1];\n          userArgs = argv.slice(2);\n        } else {\n          userArgs = argv.slice(1);\n        }\n        break;\n      case 'user':\n        userArgs = argv.slice(0);\n        break;\n      default:\n        throw new Error(`unexpected parse option { from: '${parseOptions.from}' }`);\n    }\n\n    // Find default name for program from arguments.\n    if (!this._name && this._scriptPath) this.nameFromFilename(this._scriptPath);\n    this._name = this._name || 'program';\n\n    return userArgs;\n  }\n\n  /**\n   * Parse `argv`, setting options and invoking commands when defined.\n   *\n   * The default expectation is that the arguments are from node and have the application as argv[0]\n   * and the script being run in argv[1], with user parameters after that.\n   *\n   * @example\n   * program.parse(process.argv);\n   * program.parse(); // implicitly use process.argv and auto-detect node vs electron conventions\n   * program.parse(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]\n   *\n   * @param {string[]} [argv] - optional, defaults to process.argv\n   * @param {Object} [parseOptions] - optionally specify style of options with from: node/user/electron\n   * @param {string} [parseOptions.from] - where the args are from: 'node', 'user', 'electron'\n   * @return {Command} `this` command for chaining\n   */\n\n  parse(argv, parseOptions) {\n    const userArgs = this._prepareUserArgs(argv, parseOptions);\n    this._parseCommand([], userArgs);\n\n    return this;\n  }\n\n  /**\n   * Parse `argv`, setting options and invoking commands when defined.\n   *\n   * Use parseAsync instead of parse if any of your action handlers are async. Returns a Promise.\n   *\n   * The default expectation is that the arguments are from node and have the application as argv[0]\n   * and the script being run in argv[1], with user parameters after that.\n   *\n   * @example\n   * await program.parseAsync(process.argv);\n   * await program.parseAsync(); // implicitly use process.argv and auto-detect node vs electron conventions\n   * await program.parseAsync(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]\n   *\n   * @param {string[]} [argv]\n   * @param {Object} [parseOptions]\n   * @param {string} parseOptions.from - where the args are from: 'node', 'user', 'electron'\n   * @return {Promise}\n   */\n\n  async parseAsync(argv, parseOptions) {\n    const userArgs = this._prepareUserArgs(argv, parseOptions);\n    await this._parseCommand([], userArgs);\n\n    return this;\n  }\n\n  /**\n   * Execute a sub-command executable.\n   *\n   * @api private\n   */\n\n  _executeSubCommand(subcommand, args) {\n    args = args.slice();\n    let launchWithNode = false; // Use node for source targets so do not need to get permissions correct, and on Windows.\n    const sourceExt = ['.js', '.ts', '.tsx', '.mjs', '.cjs'];\n\n    function findFile(baseDir, baseName) {\n      // Look for specified file\n      const localBin = path.resolve(baseDir, baseName);\n      if (fs.existsSync(localBin)) return localBin;\n\n      // Stop looking if candidate already has an expected extension.\n      if (sourceExt.includes(path.extname(baseName))) return undefined;\n\n      // Try all the extensions.\n      const foundExt = sourceExt.find(ext => fs.existsSync(`${localBin}${ext}`));\n      if (foundExt) return `${localBin}${foundExt}`;\n\n      return undefined;\n    }\n\n    // Not checking for help first. Unlikely to have mandatory and executable, and can't robustly test for help flags in external command.\n    this._checkForMissingMandatoryOptions();\n    this._checkForConflictingOptions();\n\n    // executableFile and executableDir might be full path, or just a name\n    let executableFile = subcommand._executableFile || `${this._name}-${subcommand._name}`;\n    let executableDir = this._executableDir || '';\n    if (this._scriptPath) {\n      let resolvedScriptPath; // resolve possible symlink for installed npm binary\n      try {\n        resolvedScriptPath = fs.realpathSync(this._scriptPath);\n      } catch (err) {\n        resolvedScriptPath = this._scriptPath;\n      }\n      executableDir = path.resolve(path.dirname(resolvedScriptPath), executableDir);\n    }\n\n    // Look for a local file in preference to a command in PATH.\n    if (executableDir) {\n      let localFile = findFile(executableDir, executableFile);\n\n      // Legacy search using prefix of script name instead of command name\n      if (!localFile && !subcommand._executableFile && this._scriptPath) {\n        const legacyName = path.basename(this._scriptPath, path.extname(this._scriptPath));\n        if (legacyName !== this._name) {\n          localFile = findFile(executableDir, `${legacyName}-${subcommand._name}`);\n        }\n      }\n      executableFile = localFile || executableFile;\n    }\n\n    launchWithNode = sourceExt.includes(path.extname(executableFile));\n\n    let proc;\n    if (process.platform !== 'win32') {\n      if (launchWithNode) {\n        args.unshift(executableFile);\n        // add executable arguments to spawn\n        args = incrementNodeInspectorPort(process.execArgv).concat(args);\n\n        proc = childProcess.spawn(process.argv[0], args, { stdio: 'inherit' });\n      } else {\n        proc = childProcess.spawn(executableFile, args, { stdio: 'inherit' });\n      }\n    } else {\n      args.unshift(executableFile);\n      // add executable arguments to spawn\n      args = incrementNodeInspectorPort(process.execArgv).concat(args);\n      proc = childProcess.spawn(process.execPath, args, { stdio: 'inherit' });\n    }\n\n    if (!proc.killed) { // testing mainly to avoid leak warnings during unit tests with mocked spawn\n      const signals = ['SIGUSR1', 'SIGUSR2', 'SIGTERM', 'SIGINT', 'SIGHUP'];\n      signals.forEach((signal) => {\n        // @ts-ignore\n        process.on(signal, () => {\n          if (proc.killed === false && proc.exitCode === null) {\n            proc.kill(signal);\n          }\n        });\n      });\n    }\n\n    // By default terminate process when spawned process terminates.\n    // Suppressing the exit if exitCallback defined is a bit messy and of limited use, but does allow process to stay running!\n    const exitCallback = this._exitCallback;\n    if (!exitCallback) {\n      proc.on('close', process.exit.bind(process));\n    } else {\n      proc.on('close', () => {\n        exitCallback(new CommanderError(process.exitCode || 0, 'commander.executeSubCommandAsync', '(close)'));\n      });\n    }\n    proc.on('error', (err) => {\n      // @ts-ignore\n      if (err.code === 'ENOENT') {\n        const executableDirMessage = executableDir\n          ? `searched for local subcommand relative to directory '${executableDir}'`\n          : 'no directory for search for local subcommand, use .executableDir() to supply a custom directory';\n        const executableMissing = `'${executableFile}' does not exist\n - if '${subcommand._name}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead\n - if the default executable name is not suitable, use the executableFile option to supply a custom name or path\n - ${executableDirMessage}`;\n        throw new Error(executableMissing);\n      // @ts-ignore\n      } else if (err.code === 'EACCES') {\n        throw new Error(`'${executableFile}' not executable`);\n      }\n      if (!exitCallback) {\n        process.exit(1);\n      } else {\n        const wrappedError = new CommanderError(1, 'commander.executeSubCommandAsync', '(error)');\n        wrappedError.nestedError = err;\n        exitCallback(wrappedError);\n      }\n    });\n\n    // Store the reference to the child process\n    this.runningCommand = proc;\n  }\n\n  /**\n   * @api private\n   */\n\n  _dispatchSubcommand(commandName, operands, unknown) {\n    const subCommand = this._findCommand(commandName);\n    if (!subCommand) this.help({ error: true });\n\n    let hookResult;\n    hookResult = this._chainOrCallSubCommandHook(hookResult, subCommand, 'preSubcommand');\n    hookResult = this._chainOrCall(hookResult, () => {\n      if (subCommand._executableHandler) {\n        this._executeSubCommand(subCommand, operands.concat(unknown));\n      } else {\n        return subCommand._parseCommand(operands, unknown);\n      }\n    });\n    return hookResult;\n  }\n\n  /**\n   * Invoke help directly if possible, or dispatch if necessary.\n   * e.g. help foo\n   *\n   * @api private\n   */\n\n  _dispatchHelpCommand(subcommandName) {\n    if (!subcommandName) {\n      this.help();\n    }\n    const subCommand = this._findCommand(subcommandName);\n    if (subCommand && !subCommand._executableHandler) {\n      subCommand.help();\n    }\n\n    // Fallback to parsing the help flag to invoke the help.\n    return this._dispatchSubcommand(subcommandName, [], [this._helpLongFlag]);\n  }\n\n  /**\n   * Check this.args against expected this._args.\n   *\n   * @api private\n   */\n\n  _checkNumberOfArguments() {\n    // too few\n    this._args.forEach((arg, i) => {\n      if (arg.required && this.args[i] == null) {\n        this.missingArgument(arg.name());\n      }\n    });\n    // too many\n    if (this._args.length > 0 && this._args[this._args.length - 1].variadic) {\n      return;\n    }\n    if (this.args.length > this._args.length) {\n      this._excessArguments(this.args);\n    }\n  }\n\n  /**\n   * Process this.args using this._args and save as this.processedArgs!\n   *\n   * @api private\n   */\n\n  _processArguments() {\n    const myParseArg = (argument, value, previous) => {\n      // Extra processing for nice error message on parsing failure.\n      let parsedValue = value;\n      if (value !== null && argument.parseArg) {\n        try {\n          parsedValue = argument.parseArg(value, previous);\n        } catch (err) {\n          if (err.code === 'commander.invalidArgument') {\n            const message = `error: command-argument value '${value}' is invalid for argument '${argument.name()}'. ${err.message}`;\n            this.error(message, { exitCode: err.exitCode, code: err.code });\n          }\n          throw err;\n        }\n      }\n      return parsedValue;\n    };\n\n    this._checkNumberOfArguments();\n\n    const processedArgs = [];\n    this._args.forEach((declaredArg, index) => {\n      let value = declaredArg.defaultValue;\n      if (declaredArg.variadic) {\n        // Collect together remaining arguments for passing together as an array.\n        if (index < this.args.length) {\n          value = this.args.slice(index);\n          if (declaredArg.parseArg) {\n            value = value.reduce((processed, v) => {\n              return myParseArg(declaredArg, v, processed);\n            }, declaredArg.defaultValue);\n          }\n        } else if (value === undefined) {\n          value = [];\n        }\n      } else if (index < this.args.length) {\n        value = this.args[index];\n        if (declaredArg.parseArg) {\n          value = myParseArg(declaredArg, value, declaredArg.defaultValue);\n        }\n      }\n      processedArgs[index] = value;\n    });\n    this.processedArgs = processedArgs;\n  }\n\n  /**\n   * Once we have a promise we chain, but call synchronously until then.\n   *\n   * @param {Promise|undefined} promise\n   * @param {Function} fn\n   * @return {Promise|undefined}\n   * @api private\n   */\n\n  _chainOrCall(promise, fn) {\n    // thenable\n    if (promise && promise.then && typeof promise.then === 'function') {\n      // already have a promise, chain callback\n      return promise.then(() => fn());\n    }\n    // callback might return a promise\n    return fn();\n  }\n\n  /**\n   *\n   * @param {Promise|undefined} promise\n   * @param {string} event\n   * @return {Promise|undefined}\n   * @api private\n   */\n\n  _chainOrCallHooks(promise, event) {\n    let result = promise;\n    const hooks = [];\n    getCommandAndParents(this)\n      .reverse()\n      .filter(cmd => cmd._lifeCycleHooks[event] !== undefined)\n      .forEach(hookedCommand => {\n        hookedCommand._lifeCycleHooks[event].forEach((callback) => {\n          hooks.push({ hookedCommand, callback });\n        });\n      });\n    if (event === 'postAction') {\n      hooks.reverse();\n    }\n\n    hooks.forEach((hookDetail) => {\n      result = this._chainOrCall(result, () => {\n        return hookDetail.callback(hookDetail.hookedCommand, this);\n      });\n    });\n    return result;\n  }\n\n  /**\n   *\n   * @param {Promise|undefined} promise\n   * @param {Command} subCommand\n   * @param {string} event\n   * @return {Promise|undefined}\n   * @api private\n   */\n\n  _chainOrCallSubCommandHook(promise, subCommand, event) {\n    let result = promise;\n    if (this._lifeCycleHooks[event] !== undefined) {\n      this._lifeCycleHooks[event].forEach((hook) => {\n        result = this._chainOrCall(result, () => {\n          return hook(this, subCommand);\n        });\n      });\n    }\n    return result;\n  }\n\n  /**\n   * Process arguments in context of this command.\n   * Returns action result, in case it is a promise.\n   *\n   * @api private\n   */\n\n  _parseCommand(operands, unknown) {\n    const parsed = this.parseOptions(unknown);\n    this._parseOptionsEnv(); // after cli, so parseArg not called on both cli and env\n    this._parseOptionsImplied();\n    operands = operands.concat(parsed.operands);\n    unknown = parsed.unknown;\n    this.args = operands.concat(unknown);\n\n    if (operands && this._findCommand(operands[0])) {\n      return this._dispatchSubcommand(operands[0], operands.slice(1), unknown);\n    }\n    if (this._hasImplicitHelpCommand() && operands[0] === this._helpCommandName) {\n      return this._dispatchHelpCommand(operands[1]);\n    }\n    if (this._defaultCommandName) {\n      outputHelpIfRequested(this, unknown); // Run the help for default command from parent rather than passing to default command\n      return this._dispatchSubcommand(this._defaultCommandName, operands, unknown);\n    }\n    if (this.commands.length && this.args.length === 0 && !this._actionHandler && !this._defaultCommandName) {\n      // probably missing subcommand and no handler, user needs help (and exit)\n      this.help({ error: true });\n    }\n\n    outputHelpIfRequested(this, parsed.unknown);\n    this._checkForMissingMandatoryOptions();\n    this._checkForConflictingOptions();\n\n    // We do not always call this check to avoid masking a \"better\" error, like unknown command.\n    const checkForUnknownOptions = () => {\n      if (parsed.unknown.length > 0) {\n        this.unknownOption(parsed.unknown[0]);\n      }\n    };\n\n    const commandEvent = `command:${this.name()}`;\n    if (this._actionHandler) {\n      checkForUnknownOptions();\n      this._processArguments();\n\n      let actionResult;\n      actionResult = this._chainOrCallHooks(actionResult, 'preAction');\n      actionResult = this._chainOrCall(actionResult, () => this._actionHandler(this.processedArgs));\n      if (this.parent) {\n        actionResult = this._chainOrCall(actionResult, () => {\n          this.parent.emit(commandEvent, operands, unknown); // legacy\n        });\n      }\n      actionResult = this._chainOrCallHooks(actionResult, 'postAction');\n      return actionResult;\n    }\n    if (this.parent && this.parent.listenerCount(commandEvent)) {\n      checkForUnknownOptions();\n      this._processArguments();\n      this.parent.emit(commandEvent, operands, unknown); // legacy\n    } else if (operands.length) {\n      if (this._findCommand('*')) { // legacy default command\n        return this._dispatchSubcommand('*', operands, unknown);\n      }\n      if (this.listenerCount('command:*')) {\n        // skip option check, emit event for possible misspelling suggestion\n        this.emit('command:*', operands, unknown);\n      } else if (this.commands.length) {\n        this.unknownCommand();\n      } else {\n        checkForUnknownOptions();\n        this._processArguments();\n      }\n    } else if (this.commands.length) {\n      checkForUnknownOptions();\n      // This command has subcommands and nothing hooked up at this level, so display help (and exit).\n      this.help({ error: true });\n    } else {\n      checkForUnknownOptions();\n      this._processArguments();\n      // fall through for caller to handle after calling .parse()\n    }\n  }\n\n  /**\n   * Find matching command.\n   *\n   * @api private\n   */\n  _findCommand(name) {\n    if (!name) return undefined;\n    return this.commands.find(cmd => cmd._name === name || cmd._aliases.includes(name));\n  }\n\n  /**\n   * Return an option matching `arg` if any.\n   *\n   * @param {string} arg\n   * @return {Option}\n   * @api private\n   */\n\n  _findOption(arg) {\n    return this.options.find(option => option.is(arg));\n  }\n\n  /**\n   * Display an error message if a mandatory option does not have a value.\n   * Called after checking for help flags in leaf subcommand.\n   *\n   * @api private\n   */\n\n  _checkForMissingMandatoryOptions() {\n    // Walk up hierarchy so can call in subcommand after checking for displaying help.\n    for (let cmd = this; cmd; cmd = cmd.parent) {\n      cmd.options.forEach((anOption) => {\n        if (anOption.mandatory && (cmd.getOptionValue(anOption.attributeName()) === undefined)) {\n          cmd.missingMandatoryOptionValue(anOption);\n        }\n      });\n    }\n  }\n\n  /**\n   * Display an error message if conflicting options are used together in this.\n   *\n   * @api private\n   */\n  _checkForConflictingLocalOptions() {\n    const definedNonDefaultOptions = this.options.filter(\n      (option) => {\n        const optionKey = option.attributeName();\n        if (this.getOptionValue(optionKey) === undefined) {\n          return false;\n        }\n        return this.getOptionValueSource(optionKey) !== 'default';\n      }\n    );\n\n    const optionsWithConflicting = definedNonDefaultOptions.filter(\n      (option) => option.conflictsWith.length > 0\n    );\n\n    optionsWithConflicting.forEach((option) => {\n      const conflictingAndDefined = definedNonDefaultOptions.find((defined) =>\n        option.conflictsWith.includes(defined.attributeName())\n      );\n      if (conflictingAndDefined) {\n        this._conflictingOption(option, conflictingAndDefined);\n      }\n    });\n  }\n\n  /**\n   * Display an error message if conflicting options are used together.\n   * Called after checking for help flags in leaf subcommand.\n   *\n   * @api private\n   */\n  _checkForConflictingOptions() {\n    // Walk up hierarchy so can call in subcommand after checking for displaying help.\n    for (let cmd = this; cmd; cmd = cmd.parent) {\n      cmd._checkForConflictingLocalOptions();\n    }\n  }\n\n  /**\n   * Parse options from `argv` removing known options,\n   * and return argv split into operands and unknown arguments.\n   *\n   * Examples:\n   *\n   *     argv => operands, unknown\n   *     --known kkk op => [op], []\n   *     op --known kkk => [op], []\n   *     sub --unknown uuu op => [sub], [--unknown uuu op]\n   *     sub -- --unknown uuu op => [sub --unknown uuu op], []\n   *\n   * @param {String[]} argv\n   * @return {{operands: String[], unknown: String[]}}\n   */\n\n  parseOptions(argv) {\n    const operands = []; // operands, not options or values\n    const unknown = []; // first unknown option and remaining unknown args\n    let dest = operands;\n    const args = argv.slice();\n\n    function maybeOption(arg) {\n      return arg.length > 1 && arg[0] === '-';\n    }\n\n    // parse options\n    let activeVariadicOption = null;\n    while (args.length) {\n      const arg = args.shift();\n\n      // literal\n      if (arg === '--') {\n        if (dest === unknown) dest.push(arg);\n        dest.push(...args);\n        break;\n      }\n\n      if (activeVariadicOption && !maybeOption(arg)) {\n        this.emit(`option:${activeVariadicOption.name()}`, arg);\n        continue;\n      }\n      activeVariadicOption = null;\n\n      if (maybeOption(arg)) {\n        const option = this._findOption(arg);\n        // recognised option, call listener to assign value with possible custom processing\n        if (option) {\n          if (option.required) {\n            const value = args.shift();\n            if (value === undefined) this.optionMissingArgument(option);\n            this.emit(`option:${option.name()}`, value);\n          } else if (option.optional) {\n            let value = null;\n            // historical behaviour is optional value is following arg unless an option\n            if (args.length > 0 && !maybeOption(args[0])) {\n              value = args.shift();\n            }\n            this.emit(`option:${option.name()}`, value);\n          } else { // boolean flag\n            this.emit(`option:${option.name()}`);\n          }\n          activeVariadicOption = option.variadic ? option : null;\n          continue;\n        }\n      }\n\n      // Look for combo options following single dash, eat first one if known.\n      if (arg.length > 2 && arg[0] === '-' && arg[1] !== '-') {\n        const option = this._findOption(`-${arg[1]}`);\n        if (option) {\n          if (option.required || (option.optional && this._combineFlagAndOptionalValue)) {\n            // option with value following in same argument\n            this.emit(`option:${option.name()}`, arg.slice(2));\n          } else {\n            // boolean option, emit and put back remainder of arg for further processing\n            this.emit(`option:${option.name()}`);\n            args.unshift(`-${arg.slice(2)}`);\n          }\n          continue;\n        }\n      }\n\n      // Look for known long flag with value, like --foo=bar\n      if (/^--[^=]+=/.test(arg)) {\n        const index = arg.indexOf('=');\n        const option = this._findOption(arg.slice(0, index));\n        if (option && (option.required || option.optional)) {\n          this.emit(`option:${option.name()}`, arg.slice(index + 1));\n          continue;\n        }\n      }\n\n      // Not a recognised option by this command.\n      // Might be a command-argument, or subcommand option, or unknown option, or help command or option.\n\n      // An unknown option means further arguments also classified as unknown so can be reprocessed by subcommands.\n      if (maybeOption(arg)) {\n        dest = unknown;\n      }\n\n      // If using positionalOptions, stop processing our options at subcommand.\n      if ((this._enablePositionalOptions || this._passThroughOptions) && operands.length === 0 && unknown.length === 0) {\n        if (this._findCommand(arg)) {\n          operands.push(arg);\n          if (args.length > 0) unknown.push(...args);\n          break;\n        } else if (arg === this._helpCommandName && this._hasImplicitHelpCommand()) {\n          operands.push(arg);\n          if (args.length > 0) operands.push(...args);\n          break;\n        } else if (this._defaultCommandName) {\n          unknown.push(arg);\n          if (args.length > 0) unknown.push(...args);\n          break;\n        }\n      }\n\n      // If using passThroughOptions, stop processing options at first command-argument.\n      if (this._passThroughOptions) {\n        dest.push(arg);\n        if (args.length > 0) dest.push(...args);\n        break;\n      }\n\n      // add arg\n      dest.push(arg);\n    }\n\n    return { operands, unknown };\n  }\n\n  /**\n   * Return an object containing local option values as key-value pairs.\n   *\n   * @return {Object}\n   */\n  opts() {\n    if (this._storeOptionsAsProperties) {\n      // Preserve original behaviour so backwards compatible when still using properties\n      const result = {};\n      const len = this.options.length;\n\n      for (let i = 0; i < len; i++) {\n        const key = this.options[i].attributeName();\n        result[key] = key === this._versionOptionName ? this._version : this[key];\n      }\n      return result;\n    }\n\n    return this._optionValues;\n  }\n\n  /**\n   * Return an object containing merged local and global option values as key-value pairs.\n   *\n   * @return {Object}\n   */\n  optsWithGlobals() {\n    // globals overwrite locals\n    return getCommandAndParents(this).reduce(\n      (combinedOptions, cmd) => Object.assign(combinedOptions, cmd.opts()),\n      {}\n    );\n  }\n\n  /**\n   * Display error message and exit (or call exitOverride).\n   *\n   * @param {string} message\n   * @param {Object} [errorOptions]\n   * @param {string} [errorOptions.code] - an id string representing the error\n   * @param {number} [errorOptions.exitCode] - used with process.exit\n   */\n  error(message, errorOptions) {\n    // output handling\n    this._outputConfiguration.outputError(`${message}\\n`, this._outputConfiguration.writeErr);\n    if (typeof this._showHelpAfterError === 'string') {\n      this._outputConfiguration.writeErr(`${this._showHelpAfterError}\\n`);\n    } else if (this._showHelpAfterError) {\n      this._outputConfiguration.writeErr('\\n');\n      this.outputHelp({ error: true });\n    }\n\n    // exit handling\n    const config = errorOptions || {};\n    const exitCode = config.exitCode || 1;\n    const code = config.code || 'commander.error';\n    this._exit(exitCode, code, message);\n  }\n\n  /**\n   * Apply any option related environment variables, if option does\n   * not have a value from cli or client code.\n   *\n   * @api private\n   */\n  _parseOptionsEnv() {\n    this.options.forEach((option) => {\n      if (option.envVar && option.envVar in process.env) {\n        const optionKey = option.attributeName();\n        // Priority check. Do not overwrite cli or options from unknown source (client-code).\n        if (this.getOptionValue(optionKey) === undefined || ['default', 'config', 'env'].includes(this.getOptionValueSource(optionKey))) {\n          if (option.required || option.optional) { // option can take a value\n            // keep very simple, optional always takes value\n            this.emit(`optionEnv:${option.name()}`, process.env[option.envVar]);\n          } else { // boolean\n            // keep very simple, only care that envVar defined and not the value\n            this.emit(`optionEnv:${option.name()}`);\n          }\n        }\n      }\n    });\n  }\n\n  /**\n   * Apply any implied option values, if option is undefined or default value.\n   *\n   * @api private\n   */\n  _parseOptionsImplied() {\n    const dualHelper = new DualOptions(this.options);\n    const hasCustomOptionValue = (optionKey) => {\n      return this.getOptionValue(optionKey) !== undefined && !['default', 'implied'].includes(this.getOptionValueSource(optionKey));\n    };\n    this.options\n      .filter(option => (option.implied !== undefined) &&\n        hasCustomOptionValue(option.attributeName()) &&\n        dualHelper.valueFromOption(this.getOptionValue(option.attributeName()), option))\n      .forEach((option) => {\n        Object.keys(option.implied)\n          .filter(impliedKey => !hasCustomOptionValue(impliedKey))\n          .forEach(impliedKey => {\n            this.setOptionValueWithSource(impliedKey, option.implied[impliedKey], 'implied');\n          });\n      });\n  }\n\n  /**\n   * Argument `name` is missing.\n   *\n   * @param {string} name\n   * @api private\n   */\n\n  missingArgument(name) {\n    const message = `error: missing required argument '${name}'`;\n    this.error(message, { code: 'commander.missingArgument' });\n  }\n\n  /**\n   * `Option` is missing an argument.\n   *\n   * @param {Option} option\n   * @api private\n   */\n\n  optionMissingArgument(option) {\n    const message = `error: option '${option.flags}' argument missing`;\n    this.error(message, { code: 'commander.optionMissingArgument' });\n  }\n\n  /**\n   * `Option` does not have a value, and is a mandatory option.\n   *\n   * @param {Option} option\n   * @api private\n   */\n\n  missingMandatoryOptionValue(option) {\n    const message = `error: required option '${option.flags}' not specified`;\n    this.error(message, { code: 'commander.missingMandatoryOptionValue' });\n  }\n\n  /**\n   * `Option` conflicts with another option.\n   *\n   * @param {Option} option\n   * @param {Option} conflictingOption\n   * @api private\n   */\n  _conflictingOption(option, conflictingOption) {\n    // The calling code does not know whether a negated option is the source of the\n    // value, so do some work to take an educated guess.\n    const findBestOptionFromValue = (option) => {\n      const optionKey = option.attributeName();\n      const optionValue = this.getOptionValue(optionKey);\n      const negativeOption = this.options.find(target => target.negate && optionKey === target.attributeName());\n      const positiveOption = this.options.find(target => !target.negate && optionKey === target.attributeName());\n      if (negativeOption && (\n        (negativeOption.presetArg === undefined && optionValue === false) ||\n        (negativeOption.presetArg !== undefined && optionValue === negativeOption.presetArg)\n      )) {\n        return negativeOption;\n      }\n      return positiveOption || option;\n    };\n\n    const getErrorMessage = (option) => {\n      const bestOption = findBestOptionFromValue(option);\n      const optionKey = bestOption.attributeName();\n      const source = this.getOptionValueSource(optionKey);\n      if (source === 'env') {\n        return `environment variable '${bestOption.envVar}'`;\n      }\n      return `option '${bestOption.flags}'`;\n    };\n\n    const message = `error: ${getErrorMessage(option)} cannot be used with ${getErrorMessage(conflictingOption)}`;\n    this.error(message, { code: 'commander.conflictingOption' });\n  }\n\n  /**\n   * Unknown option `flag`.\n   *\n   * @param {string} flag\n   * @api private\n   */\n\n  unknownOption(flag) {\n    if (this._allowUnknownOption) return;\n    let suggestion = '';\n\n    if (flag.startsWith('--') && this._showSuggestionAfterError) {\n      // Looping to pick up the global options too\n      let candidateFlags = [];\n      let command = this;\n      do {\n        const moreFlags = command.createHelp().visibleOptions(command)\n          .filter(option => option.long)\n          .map(option => option.long);\n        candidateFlags = candidateFlags.concat(moreFlags);\n        command = command.parent;\n      } while (command && !command._enablePositionalOptions);\n      suggestion = suggestSimilar(flag, candidateFlags);\n    }\n\n    const message = `error: unknown option '${flag}'${suggestion}`;\n    this.error(message, { code: 'commander.unknownOption' });\n  }\n\n  /**\n   * Excess arguments, more than expected.\n   *\n   * @param {string[]} receivedArgs\n   * @api private\n   */\n\n  _excessArguments(receivedArgs) {\n    if (this._allowExcessArguments) return;\n\n    const expected = this._args.length;\n    const s = (expected === 1) ? '' : 's';\n    const forSubcommand = this.parent ? ` for '${this.name()}'` : '';\n    const message = `error: too many arguments${forSubcommand}. Expected ${expected} argument${s} but got ${receivedArgs.length}.`;\n    this.error(message, { code: 'commander.excessArguments' });\n  }\n\n  /**\n   * Unknown command.\n   *\n   * @api private\n   */\n\n  unknownCommand() {\n    const unknownName = this.args[0];\n    let suggestion = '';\n\n    if (this._showSuggestionAfterError) {\n      const candidateNames = [];\n      this.createHelp().visibleCommands(this).forEach((command) => {\n        candidateNames.push(command.name());\n        // just visible alias\n        if (command.alias()) candidateNames.push(command.alias());\n      });\n      suggestion = suggestSimilar(unknownName, candidateNames);\n    }\n\n    const message = `error: unknown command '${unknownName}'${suggestion}`;\n    this.error(message, { code: 'commander.unknownCommand' });\n  }\n\n  /**\n   * Set the program version to `str`.\n   *\n   * This method auto-registers the \"-V, --version\" flag\n   * which will print the version number when passed.\n   *\n   * You can optionally supply the  flags and description to override the defaults.\n   *\n   * @param {string} str\n   * @param {string} [flags]\n   * @param {string} [description]\n   * @return {this | string} `this` command for chaining, or version string if no arguments\n   */\n\n  version(str, flags, description) {\n    if (str === undefined) return this._version;\n    this._version = str;\n    flags = flags || '-V, --version';\n    description = description || 'output the version number';\n    const versionOption = this.createOption(flags, description);\n    this._versionOptionName = versionOption.attributeName();\n    this.options.push(versionOption);\n    this.on('option:' + versionOption.name(), () => {\n      this._outputConfiguration.writeOut(`${str}\\n`);\n      this._exit(0, 'commander.version', str);\n    });\n    return this;\n  }\n\n  /**\n   * Set the description.\n   *\n   * @param {string} [str]\n   * @param {Object} [argsDescription]\n   * @return {string|Command}\n   */\n  description(str, argsDescription) {\n    if (str === undefined && argsDescription === undefined) return this._description;\n    this._description = str;\n    if (argsDescription) {\n      this._argsDescription = argsDescription;\n    }\n    return this;\n  }\n\n  /**\n   * Set the summary. Used when listed as subcommand of parent.\n   *\n   * @param {string} [str]\n   * @return {string|Command}\n   */\n  summary(str) {\n    if (str === undefined) return this._summary;\n    this._summary = str;\n    return this;\n  }\n\n  /**\n   * Set an alias for the command.\n   *\n   * You may call more than once to add multiple aliases. Only the first alias is shown in the auto-generated help.\n   *\n   * @param {string} [alias]\n   * @return {string|Command}\n   */\n\n  alias(alias) {\n    if (alias === undefined) return this._aliases[0]; // just return first, for backwards compatibility\n\n    /** @type {Command} */\n    let command = this;\n    if (this.commands.length !== 0 && this.commands[this.commands.length - 1]._executableHandler) {\n      // assume adding alias for last added executable subcommand, rather than this\n      command = this.commands[this.commands.length - 1];\n    }\n\n    if (alias === command._name) throw new Error('Command alias can\\'t be the same as its name');\n\n    command._aliases.push(alias);\n    return this;\n  }\n\n  /**\n   * Set aliases for the command.\n   *\n   * Only the first alias is shown in the auto-generated help.\n   *\n   * @param {string[]} [aliases]\n   * @return {string[]|Command}\n   */\n\n  aliases(aliases) {\n    // Getter for the array of aliases is the main reason for having aliases() in addition to alias().\n    if (aliases === undefined) return this._aliases;\n\n    aliases.forEach((alias) => this.alias(alias));\n    return this;\n  }\n\n  /**\n   * Set / get the command usage `str`.\n   *\n   * @param {string} [str]\n   * @return {String|Command}\n   */\n\n  usage(str) {\n    if (str === undefined) {\n      if (this._usage) return this._usage;\n\n      const args = this._args.map((arg) => {\n        return humanReadableArgName(arg);\n      });\n      return [].concat(\n        (this.options.length || this._hasHelpOption ? '[options]' : []),\n        (this.commands.length ? '[command]' : []),\n        (this._args.length ? args : [])\n      ).join(' ');\n    }\n\n    this._usage = str;\n    return this;\n  }\n\n  /**\n   * Get or set the name of the command.\n   *\n   * @param {string} [str]\n   * @return {string|Command}\n   */\n\n  name(str) {\n    if (str === undefined) return this._name;\n    this._name = str;\n    return this;\n  }\n\n  /**\n   * Set the name of the command from script filename, such as process.argv[1],\n   * or require.main.filename, or __filename.\n   *\n   * (Used internally and public although not documented in README.)\n   *\n   * @example\n   * program.nameFromFilename(require.main.filename);\n   *\n   * @param {string} filename\n   * @return {Command}\n   */\n\n  nameFromFilename(filename) {\n    this._name = path.basename(filename, path.extname(filename));\n\n    return this;\n  }\n\n  /**\n   * Get or set the directory for searching for executable subcommands of this command.\n   *\n   * @example\n   * program.executableDir(__dirname);\n   * // or\n   * program.executableDir('subcommands');\n   *\n   * @param {string} [path]\n   * @return {string|Command}\n   */\n\n  executableDir(path) {\n    if (path === undefined) return this._executableDir;\n    this._executableDir = path;\n    return this;\n  }\n\n  /**\n   * Return program help documentation.\n   *\n   * @param {{ error: boolean }} [contextOptions] - pass {error:true} to wrap for stderr instead of stdout\n   * @return {string}\n   */\n\n  helpInformation(contextOptions) {\n    const helper = this.createHelp();\n    if (helper.helpWidth === undefined) {\n      helper.helpWidth = (contextOptions && contextOptions.error) ? this._outputConfiguration.getErrHelpWidth() : this._outputConfiguration.getOutHelpWidth();\n    }\n    return helper.formatHelp(this, helper);\n  }\n\n  /**\n   * @api private\n   */\n\n  _getHelpContext(contextOptions) {\n    contextOptions = contextOptions || {};\n    const context = { error: !!contextOptions.error };\n    let write;\n    if (context.error) {\n      write = (arg) => this._outputConfiguration.writeErr(arg);\n    } else {\n      write = (arg) => this._outputConfiguration.writeOut(arg);\n    }\n    context.write = contextOptions.write || write;\n    context.command = this;\n    return context;\n  }\n\n  /**\n   * Output help information for this command.\n   *\n   * Outputs built-in help, and custom text added using `.addHelpText()`.\n   *\n   * @param {{ error: boolean } | Function} [contextOptions] - pass {error:true} to write to stderr instead of stdout\n   */\n\n  outputHelp(contextOptions) {\n    let deprecatedCallback;\n    if (typeof contextOptions === 'function') {\n      deprecatedCallback = contextOptions;\n      contextOptions = undefined;\n    }\n    const context = this._getHelpContext(contextOptions);\n\n    getCommandAndParents(this).reverse().forEach(command => command.emit('beforeAllHelp', context));\n    this.emit('beforeHelp', context);\n\n    let helpInformation = this.helpInformation(context);\n    if (deprecatedCallback) {\n      helpInformation = deprecatedCallback(helpInformation);\n      if (typeof helpInformation !== 'string' && !Buffer.isBuffer(helpInformation)) {\n        throw new Error('outputHelp callback must return a string or a Buffer');\n      }\n    }\n    context.write(helpInformation);\n\n    this.emit(this._helpLongFlag); // deprecated\n    this.emit('afterHelp', context);\n    getCommandAndParents(this).forEach(command => command.emit('afterAllHelp', context));\n  }\n\n  /**\n   * You can pass in flags and a description to override the help\n   * flags and help description for your command. Pass in false to\n   * disable the built-in help option.\n   *\n   * @param {string | boolean} [flags]\n   * @param {string} [description]\n   * @return {Command} `this` command for chaining\n   */\n\n  helpOption(flags, description) {\n    if (typeof flags === 'boolean') {\n      this._hasHelpOption = flags;\n      return this;\n    }\n    this._helpFlags = flags || this._helpFlags;\n    this._helpDescription = description || this._helpDescription;\n\n    const helpFlags = splitOptionFlags(this._helpFlags);\n    this._helpShortFlag = helpFlags.shortFlag;\n    this._helpLongFlag = helpFlags.longFlag;\n\n    return this;\n  }\n\n  /**\n   * Output help information and exit.\n   *\n   * Outputs built-in help, and custom text added using `.addHelpText()`.\n   *\n   * @param {{ error: boolean }} [contextOptions] - pass {error:true} to write to stderr instead of stdout\n   */\n\n  help(contextOptions) {\n    this.outputHelp(contextOptions);\n    let exitCode = process.exitCode || 0;\n    if (exitCode === 0 && contextOptions && typeof contextOptions !== 'function' && contextOptions.error) {\n      exitCode = 1;\n    }\n    // message: do not have all displayed text available so only passing placeholder.\n    this._exit(exitCode, 'commander.help', '(outputHelp)');\n  }\n\n  /**\n   * Add additional text to be displayed with the built-in help.\n   *\n   * Position is 'before' or 'after' to affect just this command,\n   * and 'beforeAll' or 'afterAll' to affect this command and all its subcommands.\n   *\n   * @param {string} position - before or after built-in help\n   * @param {string | Function} text - string to add, or a function returning a string\n   * @return {Command} `this` command for chaining\n   */\n  addHelpText(position, text) {\n    const allowedValues = ['beforeAll', 'before', 'after', 'afterAll'];\n    if (!allowedValues.includes(position)) {\n      throw new Error(`Unexpected value for position to addHelpText.\nExpecting one of '${allowedValues.join(\"', '\")}'`);\n    }\n    const helpEvent = `${position}Help`;\n    this.on(helpEvent, (context) => {\n      let helpStr;\n      if (typeof text === 'function') {\n        helpStr = text({ error: context.error, command: context.command });\n      } else {\n        helpStr = text;\n      }\n      // Ignore falsy value when nothing to output.\n      if (helpStr) {\n        context.write(`${helpStr}\\n`);\n      }\n    });\n    return this;\n  }\n}\n\n/**\n * Output help information if help flags specified\n *\n * @param {Command} cmd - command to output help for\n * @param {Array} args - array of options to search for help flags\n * @api private\n */\n\nfunction outputHelpIfRequested(cmd, args) {\n  const helpOption = cmd._hasHelpOption && args.find(arg => arg === cmd._helpLongFlag || arg === cmd._helpShortFlag);\n  if (helpOption) {\n    cmd.outputHelp();\n    // (Do not have all displayed text available so only passing placeholder.)\n    cmd._exit(0, 'commander.helpDisplayed', '(outputHelp)');\n  }\n}\n\n/**\n * Scan arguments and increment port number for inspect calls (to avoid conflicts when spawning new command).\n *\n * @param {string[]} args - array of arguments from node.execArgv\n * @returns {string[]}\n * @api private\n */\n\nfunction incrementNodeInspectorPort(args) {\n  // Testing for these options:\n  //  --inspect[=[host:]port]\n  //  --inspect-brk[=[host:]port]\n  //  --inspect-port=[host:]port\n  return args.map((arg) => {\n    if (!arg.startsWith('--inspect')) {\n      return arg;\n    }\n    let debugOption;\n    let debugHost = '127.0.0.1';\n    let debugPort = '9229';\n    let match;\n    if ((match = arg.match(/^(--inspect(-brk)?)$/)) !== null) {\n      // e.g. --inspect\n      debugOption = match[1];\n    } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null) {\n      debugOption = match[1];\n      if (/^\\d+$/.test(match[3])) {\n        // e.g. --inspect=1234\n        debugPort = match[3];\n      } else {\n        // e.g. --inspect=localhost\n        debugHost = match[3];\n      }\n    } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+):(\\d+)$/)) !== null) {\n      // e.g. --inspect=localhost:1234\n      debugOption = match[1];\n      debugHost = match[3];\n      debugPort = match[4];\n    }\n\n    if (debugOption && debugPort !== '0') {\n      return `${debugOption}=${debugHost}:${parseInt(debugPort) + 1}`;\n    }\n    return arg;\n  });\n}\n\n/**\n * @param {Command} startCommand\n * @returns {Command[]}\n * @api private\n */\n\nfunction getCommandAndParents(startCommand) {\n  const result = [];\n  for (let command = startCommand; command; command = command.parent) {\n    result.push(command);\n  }\n  return result;\n}\n\nexports.Command = Command;\n","// @ts-check\n\n/**\n * CommanderError class\n * @class\n */\nclass CommanderError extends Error {\n  /**\n   * Constructs the CommanderError class\n   * @param {number} exitCode suggested exit code which could be used with process.exit\n   * @param {string} code an id string representing the error\n   * @param {string} message human-readable description of the error\n   * @constructor\n   */\n  constructor(exitCode, code, message) {\n    super(message);\n    // properly capture stack trace in Node.js\n    Error.captureStackTrace(this, this.constructor);\n    this.name = this.constructor.name;\n    this.code = code;\n    this.exitCode = exitCode;\n    this.nestedError = undefined;\n  }\n}\n\n/**\n * InvalidArgumentError class\n * @class\n */\nclass InvalidArgumentError extends CommanderError {\n  /**\n   * Constructs the InvalidArgumentError class\n   * @param {string} [message] explanation of why argument is invalid\n   * @constructor\n   */\n  constructor(message) {\n    super(1, 'commander.invalidArgument', message);\n    // properly capture stack trace in Node.js\n    Error.captureStackTrace(this, this.constructor);\n    this.name = this.constructor.name;\n  }\n}\n\nexports.CommanderError = CommanderError;\nexports.InvalidArgumentError = InvalidArgumentError;\n","const { humanReadableArgName } = require('./argument.js');\n\n/**\n * TypeScript import types for JSDoc, used by Visual Studio Code IntelliSense and `npm run typescript-checkJS`\n * https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#import-types\n * @typedef { import(\"./argument.js\").Argument } Argument\n * @typedef { import(\"./command.js\").Command } Command\n * @typedef { import(\"./option.js\").Option } Option\n */\n\n// @ts-check\n\n// Although this is a class, methods are static in style to allow override using subclass or just functions.\nclass Help {\n  constructor() {\n    this.helpWidth = undefined;\n    this.sortSubcommands = false;\n    this.sortOptions = false;\n    this.showGlobalOptions = false;\n  }\n\n  /**\n   * Get an array of the visible subcommands. Includes a placeholder for the implicit help command, if there is one.\n   *\n   * @param {Command} cmd\n   * @returns {Command[]}\n   */\n\n  visibleCommands(cmd) {\n    const visibleCommands = cmd.commands.filter(cmd => !cmd._hidden);\n    if (cmd._hasImplicitHelpCommand()) {\n      // Create a command matching the implicit help command.\n      const [, helpName, helpArgs] = cmd._helpCommandnameAndArgs.match(/([^ ]+) *(.*)/);\n      const helpCommand = cmd.createCommand(helpName)\n        .helpOption(false);\n      helpCommand.description(cmd._helpCommandDescription);\n      if (helpArgs) helpCommand.arguments(helpArgs);\n      visibleCommands.push(helpCommand);\n    }\n    if (this.sortSubcommands) {\n      visibleCommands.sort((a, b) => {\n        // @ts-ignore: overloaded return type\n        return a.name().localeCompare(b.name());\n      });\n    }\n    return visibleCommands;\n  }\n\n  /**\n   * Compare options for sort.\n   *\n   * @param {Option} a\n   * @param {Option} b\n   * @returns number\n   */\n  compareOptions(a, b) {\n    const getSortKey = (option) => {\n      // WYSIWYG for order displayed in help. Short used for comparison if present. No special handling for negated.\n      return option.short ? option.short.replace(/^-/, '') : option.long.replace(/^--/, '');\n    };\n    return getSortKey(a).localeCompare(getSortKey(b));\n  }\n\n  /**\n   * Get an array of the visible options. Includes a placeholder for the implicit help option, if there is one.\n   *\n   * @param {Command} cmd\n   * @returns {Option[]}\n   */\n\n  visibleOptions(cmd) {\n    const visibleOptions = cmd.options.filter((option) => !option.hidden);\n    // Implicit help\n    const showShortHelpFlag = cmd._hasHelpOption && cmd._helpShortFlag && !cmd._findOption(cmd._helpShortFlag);\n    const showLongHelpFlag = cmd._hasHelpOption && !cmd._findOption(cmd._helpLongFlag);\n    if (showShortHelpFlag || showLongHelpFlag) {\n      let helpOption;\n      if (!showShortHelpFlag) {\n        helpOption = cmd.createOption(cmd._helpLongFlag, cmd._helpDescription);\n      } else if (!showLongHelpFlag) {\n        helpOption = cmd.createOption(cmd._helpShortFlag, cmd._helpDescription);\n      } else {\n        helpOption = cmd.createOption(cmd._helpFlags, cmd._helpDescription);\n      }\n      visibleOptions.push(helpOption);\n    }\n    if (this.sortOptions) {\n      visibleOptions.sort(this.compareOptions);\n    }\n    return visibleOptions;\n  }\n\n  /**\n   * Get an array of the visible global options. (Not including help.)\n   *\n   * @param {Command} cmd\n   * @returns {Option[]}\n   */\n\n  visibleGlobalOptions(cmd) {\n    if (!this.showGlobalOptions) return [];\n\n    const globalOptions = [];\n    for (let parentCmd = cmd.parent; parentCmd; parentCmd = parentCmd.parent) {\n      const visibleOptions = parentCmd.options.filter((option) => !option.hidden);\n      globalOptions.push(...visibleOptions);\n    }\n    if (this.sortOptions) {\n      globalOptions.sort(this.compareOptions);\n    }\n    return globalOptions;\n  }\n\n  /**\n   * Get an array of the arguments if any have a description.\n   *\n   * @param {Command} cmd\n   * @returns {Argument[]}\n   */\n\n  visibleArguments(cmd) {\n    // Side effect! Apply the legacy descriptions before the arguments are displayed.\n    if (cmd._argsDescription) {\n      cmd._args.forEach(argument => {\n        argument.description = argument.description || cmd._argsDescription[argument.name()] || '';\n      });\n    }\n\n    // If there are any arguments with a description then return all the arguments.\n    if (cmd._args.find(argument => argument.description)) {\n      return cmd._args;\n    }\n    return [];\n  }\n\n  /**\n   * Get the command term to show in the list of subcommands.\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n  subcommandTerm(cmd) {\n    // Legacy. Ignores custom usage string, and nested commands.\n    const args = cmd._args.map(arg => humanReadableArgName(arg)).join(' ');\n    return cmd._name +\n      (cmd._aliases[0] ? '|' + cmd._aliases[0] : '') +\n      (cmd.options.length ? ' [options]' : '') + // simplistic check for non-help option\n      (args ? ' ' + args : '');\n  }\n\n  /**\n   * Get the option term to show in the list of options.\n   *\n   * @param {Option} option\n   * @returns {string}\n   */\n\n  optionTerm(option) {\n    return option.flags;\n  }\n\n  /**\n   * Get the argument term to show in the list of arguments.\n   *\n   * @param {Argument} argument\n   * @returns {string}\n   */\n\n  argumentTerm(argument) {\n    return argument.name();\n  }\n\n  /**\n   * Get the longest command term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  longestSubcommandTermLength(cmd, helper) {\n    return helper.visibleCommands(cmd).reduce((max, command) => {\n      return Math.max(max, helper.subcommandTerm(command).length);\n    }, 0);\n  }\n\n  /**\n   * Get the longest option term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  longestOptionTermLength(cmd, helper) {\n    return helper.visibleOptions(cmd).reduce((max, option) => {\n      return Math.max(max, helper.optionTerm(option).length);\n    }, 0);\n  }\n\n  /**\n   * Get the longest global option term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  longestGlobalOptionTermLength(cmd, helper) {\n    return helper.visibleGlobalOptions(cmd).reduce((max, option) => {\n      return Math.max(max, helper.optionTerm(option).length);\n    }, 0);\n  }\n\n  /**\n   * Get the longest argument term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  longestArgumentTermLength(cmd, helper) {\n    return helper.visibleArguments(cmd).reduce((max, argument) => {\n      return Math.max(max, helper.argumentTerm(argument).length);\n    }, 0);\n  }\n\n  /**\n   * Get the command usage to be displayed at the top of the built-in help.\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n  commandUsage(cmd) {\n    // Usage\n    let cmdName = cmd._name;\n    if (cmd._aliases[0]) {\n      cmdName = cmdName + '|' + cmd._aliases[0];\n    }\n    let parentCmdNames = '';\n    for (let parentCmd = cmd.parent; parentCmd; parentCmd = parentCmd.parent) {\n      parentCmdNames = parentCmd.name() + ' ' + parentCmdNames;\n    }\n    return parentCmdNames + cmdName + ' ' + cmd.usage();\n  }\n\n  /**\n   * Get the description for the command.\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n  commandDescription(cmd) {\n    // @ts-ignore: overloaded return type\n    return cmd.description();\n  }\n\n  /**\n   * Get the subcommand summary to show in the list of subcommands.\n   * (Fallback to description for backwards compatibility.)\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n  subcommandDescription(cmd) {\n    // @ts-ignore: overloaded return type\n    return cmd.summary() || cmd.description();\n  }\n\n  /**\n   * Get the option description to show in the list of options.\n   *\n   * @param {Option} option\n   * @return {string}\n   */\n\n  optionDescription(option) {\n    const extraInfo = [];\n\n    if (option.argChoices) {\n      extraInfo.push(\n        // use stringify to match the display of the default value\n        `choices: ${option.argChoices.map((choice) => JSON.stringify(choice)).join(', ')}`);\n    }\n    if (option.defaultValue !== undefined) {\n      // default for boolean and negated more for programmer than end user,\n      // but show true/false for boolean option as may be for hand-rolled env or config processing.\n      const showDefault = option.required || option.optional ||\n        (option.isBoolean() && typeof option.defaultValue === 'boolean');\n      if (showDefault) {\n        extraInfo.push(`default: ${option.defaultValueDescription || JSON.stringify(option.defaultValue)}`);\n      }\n    }\n    // preset for boolean and negated are more for programmer than end user\n    if (option.presetArg !== undefined && option.optional) {\n      extraInfo.push(`preset: ${JSON.stringify(option.presetArg)}`);\n    }\n    if (option.envVar !== undefined) {\n      extraInfo.push(`env: ${option.envVar}`);\n    }\n    if (extraInfo.length > 0) {\n      return `${option.description} (${extraInfo.join(', ')})`;\n    }\n\n    return option.description;\n  }\n\n  /**\n   * Get the argument description to show in the list of arguments.\n   *\n   * @param {Argument} argument\n   * @return {string}\n   */\n\n  argumentDescription(argument) {\n    const extraInfo = [];\n    if (argument.argChoices) {\n      extraInfo.push(\n        // use stringify to match the display of the default value\n        `choices: ${argument.argChoices.map((choice) => JSON.stringify(choice)).join(', ')}`);\n    }\n    if (argument.defaultValue !== undefined) {\n      extraInfo.push(`default: ${argument.defaultValueDescription || JSON.stringify(argument.defaultValue)}`);\n    }\n    if (extraInfo.length > 0) {\n      const extraDescripton = `(${extraInfo.join(', ')})`;\n      if (argument.description) {\n        return `${argument.description} ${extraDescripton}`;\n      }\n      return extraDescripton;\n    }\n    return argument.description;\n  }\n\n  /**\n   * Generate the built-in help text.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {string}\n   */\n\n  formatHelp(cmd, helper) {\n    const termWidth = helper.padWidth(cmd, helper);\n    const helpWidth = helper.helpWidth || 80;\n    const itemIndentWidth = 2;\n    const itemSeparatorWidth = 2; // between term and description\n    function formatItem(term, description) {\n      if (description) {\n        const fullText = `${term.padEnd(termWidth + itemSeparatorWidth)}${description}`;\n        return helper.wrap(fullText, helpWidth - itemIndentWidth, termWidth + itemSeparatorWidth);\n      }\n      return term;\n    }\n    function formatList(textArray) {\n      return textArray.join('\\n').replace(/^/gm, ' '.repeat(itemIndentWidth));\n    }\n\n    // Usage\n    let output = [`Usage: ${helper.commandUsage(cmd)}`, ''];\n\n    // Description\n    const commandDescription = helper.commandDescription(cmd);\n    if (commandDescription.length > 0) {\n      output = output.concat([helper.wrap(commandDescription, helpWidth, 0), '']);\n    }\n\n    // Arguments\n    const argumentList = helper.visibleArguments(cmd).map((argument) => {\n      return formatItem(helper.argumentTerm(argument), helper.argumentDescription(argument));\n    });\n    if (argumentList.length > 0) {\n      output = output.concat(['Arguments:', formatList(argumentList), '']);\n    }\n\n    // Options\n    const optionList = helper.visibleOptions(cmd).map((option) => {\n      return formatItem(helper.optionTerm(option), helper.optionDescription(option));\n    });\n    if (optionList.length > 0) {\n      output = output.concat(['Options:', formatList(optionList), '']);\n    }\n\n    if (this.showGlobalOptions) {\n      const globalOptionList = helper.visibleGlobalOptions(cmd).map((option) => {\n        return formatItem(helper.optionTerm(option), helper.optionDescription(option));\n      });\n      if (globalOptionList.length > 0) {\n        output = output.concat(['Global Options:', formatList(globalOptionList), '']);\n      }\n    }\n\n    // Commands\n    const commandList = helper.visibleCommands(cmd).map((cmd) => {\n      return formatItem(helper.subcommandTerm(cmd), helper.subcommandDescription(cmd));\n    });\n    if (commandList.length > 0) {\n      output = output.concat(['Commands:', formatList(commandList), '']);\n    }\n\n    return output.join('\\n');\n  }\n\n  /**\n   * Calculate the pad width from the maximum term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  padWidth(cmd, helper) {\n    return Math.max(\n      helper.longestOptionTermLength(cmd, helper),\n      helper.longestGlobalOptionTermLength(cmd, helper),\n      helper.longestSubcommandTermLength(cmd, helper),\n      helper.longestArgumentTermLength(cmd, helper)\n    );\n  }\n\n  /**\n   * Wrap the given string to width characters per line, with lines after the first indented.\n   * Do not wrap if insufficient room for wrapping (minColumnWidth), or string is manually formatted.\n   *\n   * @param {string} str\n   * @param {number} width\n   * @param {number} indent\n   * @param {number} [minColumnWidth=40]\n   * @return {string}\n   *\n   */\n\n  wrap(str, width, indent, minColumnWidth = 40) {\n    // Full \\s characters, minus the linefeeds.\n    const indents = ' \\\\f\\\\t\\\\v\\u00a0\\u1680\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff';\n    // Detect manually wrapped and indented strings by searching for line break followed by spaces.\n    const manualIndent = new RegExp(`[\\\\n][${indents}]+`);\n    if (str.match(manualIndent)) return str;\n    // Do not wrap if not enough room for a wrapped column of text (as could end up with a word per line).\n    const columnWidth = width - indent;\n    if (columnWidth < minColumnWidth) return str;\n\n    const leadingStr = str.slice(0, indent);\n    const columnText = str.slice(indent).replace('\\r\\n', '\\n');\n    const indentString = ' '.repeat(indent);\n    const zeroWidthSpace = '\\u200B';\n    const breaks = `\\\\s${zeroWidthSpace}`;\n    // Match line end (so empty lines don't collapse),\n    // or as much text as will fit in column, or excess text up to first break.\n    const regex = new RegExp(`\\n|.{1,${columnWidth - 1}}([${breaks}]|$)|[^${breaks}]+?([${breaks}]|$)`, 'g');\n    const lines = columnText.match(regex) || [];\n    return leadingStr + lines.map((line, i) => {\n      if (line === '\\n') return ''; // preserve empty lines\n      return ((i > 0) ? indentString : '') + line.trimEnd();\n    }).join('\\n');\n  }\n}\n\nexports.Help = Help;\n","const { InvalidArgumentError } = require('./error.js');\n\n// @ts-check\n\nclass Option {\n  /**\n   * Initialize a new `Option` with the given `flags` and `description`.\n   *\n   * @param {string} flags\n   * @param {string} [description]\n   */\n\n  constructor(flags, description) {\n    this.flags = flags;\n    this.description = description || '';\n\n    this.required = flags.includes('<'); // A value must be supplied when the option is specified.\n    this.optional = flags.includes('['); // A value is optional when the option is specified.\n    // variadic test ignores <value,...> et al which might be used to describe custom splitting of single argument\n    this.variadic = /\\w\\.\\.\\.[>\\]]$/.test(flags); // The option can take multiple values.\n    this.mandatory = false; // The option must have a value after parsing, which usually means it must be specified on command line.\n    const optionFlags = splitOptionFlags(flags);\n    this.short = optionFlags.shortFlag;\n    this.long = optionFlags.longFlag;\n    this.negate = false;\n    if (this.long) {\n      this.negate = this.long.startsWith('--no-');\n    }\n    this.defaultValue = undefined;\n    this.defaultValueDescription = undefined;\n    this.presetArg = undefined;\n    this.envVar = undefined;\n    this.parseArg = undefined;\n    this.hidden = false;\n    this.argChoices = undefined;\n    this.conflictsWith = [];\n    this.implied = undefined;\n  }\n\n  /**\n   * Set the default value, and optionally supply the description to be displayed in the help.\n   *\n   * @param {any} value\n   * @param {string} [description]\n   * @return {Option}\n   */\n\n  default(value, description) {\n    this.defaultValue = value;\n    this.defaultValueDescription = description;\n    return this;\n  }\n\n  /**\n   * Preset to use when option used without option-argument, especially optional but also boolean and negated.\n   * The custom processing (parseArg) is called.\n   *\n   * @example\n   * new Option('--color').default('GREYSCALE').preset('RGB');\n   * new Option('--donate [amount]').preset('20').argParser(parseFloat);\n   *\n   * @param {any} arg\n   * @return {Option}\n   */\n\n  preset(arg) {\n    this.presetArg = arg;\n    return this;\n  }\n\n  /**\n   * Add option name(s) that conflict with this option.\n   * An error will be displayed if conflicting options are found during parsing.\n   *\n   * @example\n   * new Option('--rgb').conflicts('cmyk');\n   * new Option('--js').conflicts(['ts', 'jsx']);\n   *\n   * @param {string | string[]} names\n   * @return {Option}\n   */\n\n  conflicts(names) {\n    this.conflictsWith = this.conflictsWith.concat(names);\n    return this;\n  }\n\n  /**\n   * Specify implied option values for when this option is set and the implied options are not.\n   *\n   * The custom processing (parseArg) is not called on the implied values.\n   *\n   * @example\n   * program\n   *   .addOption(new Option('--log', 'write logging information to file'))\n   *   .addOption(new Option('--trace', 'log extra details').implies({ log: 'trace.txt' }));\n   *\n   * @param {Object} impliedOptionValues\n   * @return {Option}\n   */\n  implies(impliedOptionValues) {\n    let newImplied = impliedOptionValues;\n    if (typeof impliedOptionValues === 'string') {\n      // string is not documented, but easy mistake and we can do what user probably intended.\n      newImplied = { [impliedOptionValues]: true };\n    }\n    this.implied = Object.assign(this.implied || {}, newImplied);\n    return this;\n  }\n\n  /**\n   * Set environment variable to check for option value.\n   *\n   * An environment variable is only used if when processed the current option value is\n   * undefined, or the source of the current value is 'default' or 'config' or 'env'.\n   *\n   * @param {string} name\n   * @return {Option}\n   */\n\n  env(name) {\n    this.envVar = name;\n    return this;\n  }\n\n  /**\n   * Set the custom handler for processing CLI option arguments into option values.\n   *\n   * @param {Function} [fn]\n   * @return {Option}\n   */\n\n  argParser(fn) {\n    this.parseArg = fn;\n    return this;\n  }\n\n  /**\n   * Whether the option is mandatory and must have a value after parsing.\n   *\n   * @param {boolean} [mandatory=true]\n   * @return {Option}\n   */\n\n  makeOptionMandatory(mandatory = true) {\n    this.mandatory = !!mandatory;\n    return this;\n  }\n\n  /**\n   * Hide option in help.\n   *\n   * @param {boolean} [hide=true]\n   * @return {Option}\n   */\n\n  hideHelp(hide = true) {\n    this.hidden = !!hide;\n    return this;\n  }\n\n  /**\n   * @api private\n   */\n\n  _concatValue(value, previous) {\n    if (previous === this.defaultValue || !Array.isArray(previous)) {\n      return [value];\n    }\n\n    return previous.concat(value);\n  }\n\n  /**\n   * Only allow option value to be one of choices.\n   *\n   * @param {string[]} values\n   * @return {Option}\n   */\n\n  choices(values) {\n    this.argChoices = values.slice();\n    this.parseArg = (arg, previous) => {\n      if (!this.argChoices.includes(arg)) {\n        throw new InvalidArgumentError(`Allowed choices are ${this.argChoices.join(', ')}.`);\n      }\n      if (this.variadic) {\n        return this._concatValue(arg, previous);\n      }\n      return arg;\n    };\n    return this;\n  }\n\n  /**\n   * Return option name.\n   *\n   * @return {string}\n   */\n\n  name() {\n    if (this.long) {\n      return this.long.replace(/^--/, '');\n    }\n    return this.short.replace(/^-/, '');\n  }\n\n  /**\n   * Return option name, in a camelcase format that can be used\n   * as a object attribute key.\n   *\n   * @return {string}\n   * @api private\n   */\n\n  attributeName() {\n    return camelcase(this.name().replace(/^no-/, ''));\n  }\n\n  /**\n   * Check if `arg` matches the short or long flag.\n   *\n   * @param {string} arg\n   * @return {boolean}\n   * @api private\n   */\n\n  is(arg) {\n    return this.short === arg || this.long === arg;\n  }\n\n  /**\n   * Return whether a boolean option.\n   *\n   * Options are one of boolean, negated, required argument, or optional argument.\n   *\n   * @return {boolean}\n   * @api private\n   */\n\n  isBoolean() {\n    return !this.required && !this.optional && !this.negate;\n  }\n}\n\n/**\n * This class is to make it easier to work with dual options, without changing the existing\n * implementation. We support separate dual options for separate positive and negative options,\n * like `--build` and `--no-build`, which share a single option value. This works nicely for some\n * use cases, but is tricky for others where we want separate behaviours despite\n * the single shared option value.\n */\nclass DualOptions {\n  /**\n   * @param {Option[]} options\n   */\n  constructor(options) {\n    this.positiveOptions = new Map();\n    this.negativeOptions = new Map();\n    this.dualOptions = new Set();\n    options.forEach(option => {\n      if (option.negate) {\n        this.negativeOptions.set(option.attributeName(), option);\n      } else {\n        this.positiveOptions.set(option.attributeName(), option);\n      }\n    });\n    this.negativeOptions.forEach((value, key) => {\n      if (this.positiveOptions.has(key)) {\n        this.dualOptions.add(key);\n      }\n    });\n  }\n\n  /**\n   * Did the value come from the option, and not from possible matching dual option?\n   *\n   * @param {any} value\n   * @param {Option} option\n   * @returns {boolean}\n   */\n  valueFromOption(value, option) {\n    const optionKey = option.attributeName();\n    if (!this.dualOptions.has(optionKey)) return true;\n\n    // Use the value to deduce if (probably) came from the option.\n    const preset = this.negativeOptions.get(optionKey).presetArg;\n    const negativeValue = (preset !== undefined) ? preset : false;\n    return option.negate === (negativeValue === value);\n  }\n}\n\n/**\n * Convert string from kebab-case to camelCase.\n *\n * @param {string} str\n * @return {string}\n * @api private\n */\n\nfunction camelcase(str) {\n  return str.split('-').reduce((str, word) => {\n    return str + word[0].toUpperCase() + word.slice(1);\n  });\n}\n\n/**\n * Split the short and long flag out of something like '-m,--mixed <value>'\n *\n * @api private\n */\n\nfunction splitOptionFlags(flags) {\n  let shortFlag;\n  let longFlag;\n  // Use original very loose parsing to maintain backwards compatibility for now,\n  // which allowed for example unintended `-sw, --short-word` [sic].\n  const flagParts = flags.split(/[ |,]+/);\n  if (flagParts.length > 1 && !/^[[<]/.test(flagParts[1])) shortFlag = flagParts.shift();\n  longFlag = flagParts.shift();\n  // Add support for lone short flag without significantly changing parsing!\n  if (!shortFlag && /^-[^-]$/.test(longFlag)) {\n    shortFlag = longFlag;\n    longFlag = undefined;\n  }\n  return { shortFlag, longFlag };\n}\n\nexports.Option = Option;\nexports.splitOptionFlags = splitOptionFlags;\nexports.DualOptions = DualOptions;\n","const maxDistance = 3;\n\nfunction editDistance(a, b) {\n  // https://en.wikipedia.org/wiki/DamerauLevenshtein_distance\n  // Calculating optimal string alignment distance, no substring is edited more than once.\n  // (Simple implementation.)\n\n  // Quick early exit, return worst case.\n  if (Math.abs(a.length - b.length) > maxDistance) return Math.max(a.length, b.length);\n\n  // distance between prefix substrings of a and b\n  const d = [];\n\n  // pure deletions turn a into empty string\n  for (let i = 0; i <= a.length; i++) {\n    d[i] = [i];\n  }\n  // pure insertions turn empty string into b\n  for (let j = 0; j <= b.length; j++) {\n    d[0][j] = j;\n  }\n\n  // fill matrix\n  for (let j = 1; j <= b.length; j++) {\n    for (let i = 1; i <= a.length; i++) {\n      let cost = 1;\n      if (a[i - 1] === b[j - 1]) {\n        cost = 0;\n      } else {\n        cost = 1;\n      }\n      d[i][j] = Math.min(\n        d[i - 1][j] + 1, // deletion\n        d[i][j - 1] + 1, // insertion\n        d[i - 1][j - 1] + cost // substitution\n      );\n      // transposition\n      if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {\n        d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + 1);\n      }\n    }\n  }\n\n  return d[a.length][b.length];\n}\n\n/**\n * Find close matches, restricted to same number of edits.\n *\n * @param {string} word\n * @param {string[]} candidates\n * @returns {string}\n */\n\nfunction suggestSimilar(word, candidates) {\n  if (!candidates || candidates.length === 0) return '';\n  // remove possible duplicates\n  candidates = Array.from(new Set(candidates));\n\n  const searchingOptions = word.startsWith('--');\n  if (searchingOptions) {\n    word = word.slice(2);\n    candidates = candidates.map(candidate => candidate.slice(2));\n  }\n\n  let similar = [];\n  let bestDistance = maxDistance;\n  const minSimilarity = 0.4;\n  candidates.forEach((candidate) => {\n    if (candidate.length <= 1) return; // no one character guesses\n\n    const distance = editDistance(word, candidate);\n    const length = Math.max(word.length, candidate.length);\n    const similarity = (length - distance) / length;\n    if (similarity > minSimilarity) {\n      if (distance < bestDistance) {\n        // better edit distance, throw away previous worse matches\n        bestDistance = distance;\n        similar = [candidate];\n      } else if (distance === bestDistance) {\n        similar.push(candidate);\n      }\n    }\n  });\n\n  similar.sort((a, b) => a.localeCompare(b));\n  if (searchingOptions) {\n    similar = similar.map(candidate => `--${candidate}`);\n  }\n\n  if (similar.length > 1) {\n    return `\\n(Did you mean one of ${similar.join(', ')}?)`;\n  }\n  if (similar.length === 1) {\n    return `\\n(Did you mean ${similar[0]}?)`;\n  }\n  return '';\n}\n\nexports.suggestSimilar = suggestSimilar;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import fs from \"fs\";\nfunction processEscapeSequences(contentBlock) {\n    // Replace escape sequences with corresponding characters\n    const nonUnicodeEscapeSequences = {\n        \"\\\\n\": \"\\n\",\n        \"\\\\r\": \"\\r\",\n        \"\\\\t\": \"\\t\",\n        \"\\\\f\": \"\\f\",\n        \"\\\\b\": \"\\b\",\n        \"\\\\v\": \"\\v\"\n    };\n    for (const escapeSequence in nonUnicodeEscapeSequences) {\n        contentBlock = contentBlock.replace(escapeSequence, nonUnicodeEscapeSequences[escapeSequence]);\n    }\n    let replacedContentBlock = contentBlock.replace(/\\\\(.+?)/g, (match, escapeSequence) => {\n        if (escapeSequence === \"\\\\\")\n            return \"\\\\\";\n        return String.fromCharCode(parseInt(escapeSequence, 16));\n    });\n    return replacedContentBlock;\n}\nfunction parse(input) {\n    let inputString = fs.readFileSync(input, \"utf-8\");\n    // Initialize the final output array\n    const output = [];\n    // Use regular expressions to find all tags in the input string\n    const tagRegex = /--(\\w+)\\(([^)]*)\\)\\s*{([\\s\\S]*?)}/g;\n    let tagMatch;\n    while ((tagMatch = tagRegex.exec(inputString)) !== null) {\n        const tagName = tagMatch[1];\n        const optionsBlock = tagMatch[2].trim();\n        let contentBlock = tagMatch[3].trim();\n        // Parse the options block and convert it into a dictionary\n        const optionsDict = {};\n        const optionsLines = optionsBlock.split(/\\r?\\n/);\n        for (const line of optionsLines) {\n            const [option, value] = line.split(\":\", 2);\n            if (option && value) {\n                optionsDict[option.trim()] = value.trim();\n            }\n        }\n        // Process escape sequences in the content block\n        contentBlock = processEscapeSequences(contentBlock);\n        // Create a new tag object with tagName, options, and content\n        const tagObject = {\n            tagName: tagName,\n            options: optionsDict,\n            content: contentBlock\n        };\n        // Add the tag object to the output array\n        output.push(tagObject);\n    }\n    return output;\n}\nexport default parse;\n","import commander from './index.js';\n\n// wrapper to provide named exports for ESM.\nexport const {\n  program,\n  createCommand,\n  createArgument,\n  createOption,\n  CommanderError,\n  InvalidArgumentError,\n  InvalidOptionArgumentError, // deprecated old name\n  Command,\n  Argument,\n  Option,\n  Help\n} = commander;\n","import parse from \"./parse\";\nimport { program } from \"commander\";\nprogram\n    .name(\"opus\")\n    .version(\"0.1.0\")\n    .description(\"A fully customizable programmatic document processing system\");\nprogram\n    .requiredOption(\"-i, --input <input>\", \"Input file\")\n    .option(\"-o, --output <output>\", \"Output file\", \"<input>.pdf\");\nprogram.parse();\nconst options = program.opts();\nlet parsed = parse(options.input);\nconsole.log(parsed);\n"]}